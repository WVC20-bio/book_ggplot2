
# Plots with two variables X - Y: discrete X and continuous Y {#plots-x-discrete}

This chapter presents different types of graphs designed to facilitate comparison between categories. It begins with bar graphs and their variants, due to their widespread use and effectiveness. It then introduces alternatives such as Cleveland connected dot graphs, which are useful when dealing with many categories, and a bar graph may be visually overwhelming. The use of pie charts is also addressed. Despite frequent criticism, pie charts remain common in various media, so recommendations are offered for using them effectively. Finally, charts that allow the distribution of data to be visualized, such as box plots, violin charts, and strip charts, are analyzed.

## Bar plot {#bar-plot}

This is one of the most common graphs in scientific literature, as they are easy to interpret visually. \index{Bar plot} They are generally used to represent quantities associated with a set of elements (categories). The graph is based on the length or height of the rectangular bars indicating the value of the data, which makes it easy to identify which category is the largest, the smallest or the significant difference between them [@Streit2014].

Although they facilitate the comparison of values between categories, bar charts have some limitations that are important to consider. These charts only provide a statistical summary of the data, usually representing the mean. In addition, they can be misleading when used with small data sets, so in these cases it is preferable to visualize the full distribution using a dot plot [@Hu2020].

Next we will see the types of bar charts: 

### Vertical - Single series {#bar-vertical-single}

This time, we will utilize data from a study that examined individuals without synesthesia (control group) and those with auditory synesthesia. \index{Bar plot!vertical} The study involved a complex visual assessment incorporating rhythmic temporal patterns similar to Morse code [@SAENZ2008R650].

```{r, error=FALSE, warning=FALSE, message=FALSE}

library(tidyverse)

synesthesia <- read.csv(
              file = "data/Chapter06/synesthetes.csv", 
              header = TRUE,  sep=",")

head(synesthesia, 4)

```

The `synesthesia` data consisted of one group of four auditory synaesthetes and the other group consisted of 10 control adults who were not synaesthetes (Figure \@ref(fig:barplot1)).

```{r barplot1, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "Bar plot with predetermined width.",fig.align='center'}
library(tidyverse)
synesthesia <- read.csv(
              file = "data/Chapter06/synesthetes.csv", 
              header = TRUE,  sep=",")
synesthesia2 <- synesthesia %>% 
               dplyr::group_by(group) %>% 
               dplyr::summarise(
                   Score = mean(score), 
                   DS = sd(score))
syn <- ggplot(synesthesia2, aes(x = group, y = Score )) 

syn + geom_bar(stat = "identity", 
               aes(fill = group), 
               color = "black", size = 1) +
      scale_fill_manual(
          values = c("gray50", "black")) +
      scale_y_continuous(expand = c(0, 0)) +
      labs(y = "Score (%)", x = NULL) +
      theme_us_classic() + 
      theme(legend.position = "none",
            plot.margin = margin(14, 7, 3, 1.5))

```

For this plot, it is necessary to compare the mean of both groups, and for this we will use the `summarize` function of the dplyr package. Within this function, we use the `mean()` and `sd()` arguments to calculate the mean and standard deviation, respectively. \index{mean, sd function}

```{r, warning=FALSE, message=FALSE, error=FALSE}
synesthesia2 <- synesthesia %>% 
               dplyr::group_by(group) %>% 
               dplyr::summarise(
                   Score = mean(score), 
                   DS = sd(score))
```

```{r, warning=FALSE, message=FALSE, error=FALSE}
syn <-  ggplot(synesthesia2, aes(x = group, y = Score )) 
```

To create our bars, we use the `geom_bar()` function with the argument `stat = “identity”`. \index{geom\_bar function} However, as of *ggplot2* version 2.2.0, the `geom_col()` function performs the same task. \index{geom\_col function} Subsequently, we apply color to the bars with the `fill` argument and add a border with the `color` argument. The thickness of the border is set with the `size` argument.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

syn + geom_bar(stat = "identity", 
               aes(fill = group), 
               color = "black", size = 1) +
      scale_fill_manual(
          values = c("gray50", "black")) +
      scale_y_continuous(expand = c(0, 0)) +
      labs(y = "Score (%)", x = NULL) +
      theme_us_classic() + 
      theme(legend.position = "none")

```

We still need to improve our chart by adjusting the width of the bars. These should not be so thick, so we will use the `width` argument. It is important to mention that there is no fixed rule for setting the width (Figure \@ref(fig:barplot2)).

Adding error bars is a common practice in graphs, as they allow you to visualize the standard deviation or standard error of the mean of your data (Section \@ref(error-bar)). For this, we will use the `geom_errorbar()` function, assigning the variables (Score and SD) to the values of `ymin` and `ymax`. \index{geom\_errorbar function} The inclusion of error bars is done in a similar way in both bar plots and line plots.

```{r barplot2, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "Bar plot with modified width. The error bars show the standard deviation (SD).",fig.show='hold'}
library(tidyverse)
synesthesia <-  read.csv(
              file = "data/Chapter06/synesthetes.csv", 
              header = TRUE,  sep=",")

synesthesia2 <- synesthesia %>% 
               dplyr::group_by(group) %>% 
               dplyr::summarise(
                   Score = mean(score), 
                   DS = sd(score))

synesthesia2 <- synesthesia2 %>% 
        dplyr::mutate(perc = paste0(sprintf("%4.1f", 
                      Score), "%"))
syn <- ggplot(synesthesia2, aes(x = group, y = Score )) 

syn + geom_col(aes(fill = group), 
               color = "black", size = 1, 
               width = 0.4) +
      geom_errorbar(aes(ymin = Score, 
                        ymax = Score + DS),
               width = 0.1, size = 1) +
      scale_fill_manual(
          values = c("gray50", "black")) +
      scale_y_continuous(expand = c(0, 0)) +
      scale_x_discrete(breaks = c("controls", 
                        "synesthetes"),
              labels = c("Control\n(n=10)", 
                        "Synesthetes\n(n=4)")) +
      geom_text(aes(label = perc),
      color = "white", size = 6, vjust = 2) +
      labs(y = "Score (%)", x = NULL) +
      theme_us_classic() + 
      theme(legend.position = "none",
            plot.margin = margin(14, 7, 3, 1.5))

```

In some publications, you can label numeric values directly on the chart. To label our values, we will first create the `perc` variable using dplyr's `mutate` function. \index{The tidyverse!dplyr!mutate} 

```{r, warning=FALSE, message=FALSE, error=FALSE}
synesthesia2 <- synesthesia2 %>% 
        dplyr::mutate(perc = paste0(sprintf("%4.1f", 
                      Score), "%"))
```

To add the values to our plot, we will use the function `geom_text()` together with the argument `aes(label=perc)`. It is also possible to customize the color, size and position of the labels. \index{geom\_text function} We also adjust the axis labels using the `scale_x_discrete()` function and the `breaks` argument. This argument must be specific, since the `labels` argument is then used to assign the names of your choice.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}


syn + geom_col(aes(fill = group), 
               color = "black", size = 1, 
               width = 0.4) +
      geom_errorbar(aes(ymin = Score, 
                        ymax = Score + DS),
               width = 0.1, size = 1) +
      scale_fill_manual(
          values = c("gray50", "black")) +
      scale_y_continuous(expand = c(0, 0)) +
      scale_x_discrete(breaks = c("controls", 
                        "synesthetes"),
              labels = c("Control\n(n=10)", 
                        "Synesthetes\n(n=4)")) +
      labs(y = "Score (%)", x = NULL) +
      geom_text(aes(label = perc),
      color = "white", size = 6, vjust = 2) +
      theme_us_classic() + 
      theme(legend.position = "none")

```


Now that we have learned how to create a bar plot, it is important to remember its limitations. Is it really appropriate to use this visualization to represent your data? The answer is no. Since the number of individuals analyzed is small, i.e., it is a small data set, a bar plot would not be the best choice. Instead, it is preferable to use a dot plot that allows you to visualize the full distribution of the data.

(ref:barplot-limit) Bar plot replaced by a dot plot showing the total distribution of a small data set. 

```{r barplot-limit, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6, dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:barplot-limit)',fig.align='center'}
library(tidyverse)
library(scales)
synesthesia <- read.csv(
              file = "data/Chapter06/synesthetes.csv", 
              header = TRUE,  sep=",")

ggplot(synesthesia, 
       aes(x = group,
          y = score)) +
geom_point(aes(color = group),
    size = 3, position = position_jitter(0.05)) + 
scale_color_manual(
          values = c("gray40", "black")) +
scale_y_continuous(limits = c(40,90),
    expand = c(0,0), 
    labels = scales::percent_format(
        accuracy = 1, scale = 1)) +
scale_x_discrete(breaks = c("controls", 
                        "synesthetes"),
labels = c("Control\n(n=10)", 
                        "Synesthetes\n(n=4)")) +
  labs(y = "Score (%)", x = NULL) +
  theme_us_classic() + 
  theme(legend.position = "none",
  plot.margin = margin(14, 7, 3, 1.5))

```


### Vertical - Two or more series {#bar-plot-series}

Bar plots can include two or more data series, but it is important to be cautious about adding too many, as this can make it difficult to focus on a specific series and complicate the interpretation of the information (Figure \@ref(fig:barplot3)).

In this example, we will use a data set from a prospective cohort study that investigated the impact of colistin treatment on mean minimum inhibitory concentration (MIC) changes in commensal _Escherichia coli_ within a herd of pigs [@antibio10].

(ref:barplot3) Bar plot of *E. coli* population in treated pigs with anti-diarrheal feed supplements.

```{r barplot3, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:barplot3)', fig.align='center'}

library(readxl)
library(RColorBrewer)

colistin <- read_xlsx(
           path ="data/Chapter06/colistin_resistant.xlsx", 
           col_names = TRUE)
col <- ggplot(colistin, aes(x = population, y = log10_CFU,
                           fill =count)) 

colors_three = RColorBrewer::brewer.pal(
                             4, "PuBu")[4:1]

col + geom_col(position = position_dodge(0.9),
               width = 0.6) +
      scale_y_continuous(expand = c(0, 0)) +
      scale_x_discrete(limits = 
                      c("Tet", "Amp","Col","Cef")) +
      labs(y = "Log10 CFU/gm Feces", 
           x = NULL) +
      scale_fill_manual(values = colors_three, 
                        name = NULL) +
      theme_us_classic() + 
      theme(plot.margin = margin(14, 7, 3, 1.5))

```


```{r}

library(readxl)

colistin <- read_xlsx(
           path ="data/Chapter06/colistin_resistant.xlsx", 
           col_names = TRUE)

head(colistin,4)
              
```

We will create our variable `col` and fill in the bars according to the counts before and after colistin treatment (T0 and T1).

```{r, warning=FALSE, message=FALSE, error=FALSE}
col = ggplot(colistin, aes(x = population, y = log10_CFU,
                           fill =count)) 
```

To create a grouped bar chart using a second variable (`count`), we will use the argument `position = “dodge”`. However, by default, the bars within each group have no space between them. To fix this, we will use the more flexible argument `position = position_dodge()`, where we will specify an appropriate value. We will also modify the order of the X-axis items using the `scale_x_discrete()` function and the `limits= c()` argument.

To color our bars, we will take the three darkest colors from the “PuBu” palette of 4 RColorBrewer classes, using the `brewer.pal()` function of the **RColorBrewer** package.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

colors_three <- RColorBrewer::brewer.pal(
                             4, "PuBu")[4:1]

col + geom_col(position = position_dodge(0.9),
               width = 0.6) +
      scale_y_continuous(expand = c(0, 0)) +
      scale_x_discrete(limits = 
                      c("Tet", "Amp","Col","Cef")) +
      labs(y = "Log10 CFU/gm Feces", 
           x = NULL) +
      scale_fill_manual(values = colors_three, 
                        name = NULL) +
      theme_us_classic()

```

It is important to consider the order in which the bars are presented, as this can improve the understanding of the data. We should only rearrange them if there is no natural order for the categories they represent, as is the case here.

```{r barplot4, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "Bar plot showing the different treatment groups.",fig.align='center'}

library(readxl)

colistin <- read_xlsx(
           path ="data/Chapter06/colistin_resistant.xlsx", 
           col_names = TRUE)
col <- ggplot(colistin, aes(x = population, y = log10_CFU,
                           fill =count)) 

colors_three <- RColorBrewer::brewer.pal(
                             4, "PuBu")[4:1]
col + geom_col(position = position_dodge(0.9),
               width = 0.6) +
      scale_y_continuous(expand = c(0, 0),
                         limits = c(0,8)) +
      scale_x_discrete(limits = 
                      c("Tet", "Amp","Col","Cef")) +
      labs(y = "Log10 CFU/gm Feces", 
           x = NULL) +
      scale_fill_manual(values = colors_three, 
                        name = NULL) +
      facet_wrap(~treatment_group, scales = "free_x") +
      theme_us_classic() + 
      theme(plot.margin = margin(14, 7, 3, 1.5),
        strip.background  = element_rect(
        fill = "grey85", colour = "grey85",
        linetype = 1, size = 0.25),
        strip.text = element_text(size = 14,
            hjust = 0))

```

This data set includes three categorical variables, and so far we have only shown the results of one treatment group (G3). There are two other groups of pigs (G1 and G2) that received oral colistin treatment. To visualize all treatments, we will use the `facet_wrap()` function (Figure \@ref(fig:barplot4)). \index{facet\_wrap function}

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

col + geom_col(position = position_dodge(0.9),
               width = 0.6) +
      scale_y_continuous(expand = c(0, 0),
                         limits = c(0,8)) +
      scale_x_discrete(limits = 
                      c("Tet", "Amp","Col","Cef")) +
      labs(y = "Log10 CFU/gm Feces", 
           x = NULL) +
      scale_fill_manual(values = colors_three, 
                        name = NULL) +
      facet_wrap(~treatment_group, scales = "free_x") +
      theme_us_classic() + 
       theme(strip.background  = element_rect(
        fill = "grey85", colour = "grey85",
        linetype = 1, size = 0.25),
        strip.text = element_text(size = 14,
            hjust = 0))

```

### Stacked bar plot {#stacked-bar-plot}

It is a type of bar plot that facilitates the comparison of totals between categories, while showing the subcomponents (attributes) within each category. \index{Bar plot!stacked} The segments of each bar are distinguished by different colors, allowing the subcomponents to be identified and compared. There are several forms of stacked bar charts, and a table comparing both individual and overall attributes is presented below [@INDRATMO2018155].

<br>      

<table>
<caption><span id="tab:table1">Table 1: </span>Bar plots comparing individual attributes and global attributes.</caption>

----------------------------------------------------------------------------------------------
Types of bar charts             Single-attribute comparison	    Overall-attribute comparison
------------------------------  ------------------------------  ------------------------------
Classical stacked bar chart.     Yes                             Yes

Inverting stacked bar chart.     Yes                             Yes

Diverging stacked bar chart.     Yes                             Yes

100% stacked bar chart.          Yes                              No 
----------------------------------------------------------------------------------------------

</table>

This time we will produce a 100% stacked bar chart. In this type of chart, each bar represents 100% rather than an absolute value, and the segments within the bar indicate the corresponding percentages of the total. This format makes it easy for users to quickly compare individual attributes on a relative basis. However, it is not ideal for general attribute comparisons, as all bars are the same length [@INDRATMO2018155]. 

This type of graph is commonly used in microbiome research. In this example, we will work with a reduced dataset based on 16S rRNA gene sequencing of fecal samples taken from 338 individuals, classified into three groups: healthy individuals, individuals with *Clostridium difficile* diarrhea, and individuals with non *Clostridium difficile* diarrhea [@Schubert2014].

(ref:stackedbar1) 100% stacked bar chart. There are two significant problems with this visualization: 1) It is difficult to compare the different phyla between groups. 2) The large number of colors representing the different phyla creates a visual distraction. Note: To generate this graph we used the code published by Riffomonas Professional Development [@Schloss2023].

```{r stackedbar1, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:stackedbar1)',fig.align='center'}

library(ggtext)
library(tidyverse)
library(stringr)

microbiome_otu <- read.csv(
                  "data/Chapter06/microbiome_otu",
                  header=T, stringsAsFactors=FALSE)

phylum_data <- microbiome_otu %>% 
           dplyr::filter(level == "phylum") %>%
dplyr::group_by(disease_stat,sample_id, taxon) %>%
dplyr::summarise(abun_rela = sum(abun_rela)) %>%
dplyr::group_by(disease_stat, taxon) %>%
dplyr::summarise(mean_abun_rela = 100*mean(abun_rela),
          .groups = "drop") %>%
dplyr::mutate(disease_stat = factor(disease_stat,
levels = c("NonDiarrhealControl",
"DiarrhealControl", "Case"))) %>%
dplyr::mutate(taxon = str_replace(taxon,
"(.*)_unclassified", "Unclassified *\\1*"))
m = ggplot(phylum_data,aes(x=disease_stat, 
                            y=mean_abun_rela, fill=taxon))
m + geom_col() +
  scale_fill_discrete(name=NULL) +
  scale_x_discrete(breaks=c("NonDiarrhealControl",
                            "DiarrhealControl",
                            "Case"),
  labels=c("Healthy",
            "Diarrhea,<br>*C. difficile*<br>negative",
            "Diarrhea,<br>*C. difficile*<br>positive")) +
  scale_y_continuous(expand = c(0, 0)) +
  labs(x=NULL,
       y="Mean Relative Abundance (%)") +
  theme_us_classic() +
  theme(axis.text.x = element_markdown(),
        legend.text = element_text(face = "italic"),
        legend.key.size = unit(10, "pt"),
        plot.margin = margin(14, 7, 3, 1.5))

```


The original data (*schubert.metadata, schubert*.*subsample.shared* and *schubert.cons.taxonomy*) are available in the following [GitHub](https://github.com/riffomonas/minimalR-raw_data) repository. For this case, the data has already been organized and is ready for use in this example (Figure \@ref(fig:stackedbar1)).

```{r}

microbiome_otu <- read.csv(
                  "data/Chapter06/microbiome_otu",
                  header=T, stringsAsFactors=FALSE)
```

From the large `microbiome_otu` dataset, we will only present phylum-level information, generating a new variable called `phylum_data`. In this variable, the average relative abundance in percent was calculated using the argument `100*mean()`. In addition, the groups were sorted and the labels of unclassified bacteria were replaced appropriately using the `str_replace()` argument. \index{str\_replace function}

```{r, warning=FALSE, message=FALSE, error=FALSE}
# Data at phylum level
phylum_data <- microbiome_otu %>% 
           filter(level == "phylum") %>%
dplyr::group_by(disease_stat,sample_id, taxon) %>%
dplyr::summarise(abun_rela = sum(abun_rela)) %>%
dplyr::group_by(disease_stat, taxon) %>%
# Mean relative abundance
summarise(mean_abun_rela = 100*mean(abun_rela),
          .groups = "drop") %>%
# We order our groups
mutate(disease_stat = factor(disease_stat,
levels = c("NonDiarrhealControl",
"DiarrhealControl", "Case"))) %>%
# Appropriate replacement of unclassified bacteria
mutate(taxon = str_replace(taxon,
"(.*)_unclassified", "Unclassified *\\1*"))
head(phylum_data,4)
```

After some modifications, we will create our first stacked bar plot (Figure \@ref(fig:stackedbar1)).

```{r, warning=FALSE, message=FALSE, error=FALSE}
m <- ggplot(phylum_data,aes(x=disease_stat, 
                            y=mean_abun_rela, fill=taxon))
```

The stacked bar plots were generated without the need to specify additional parameters in the `geom_col()` function. \index{geom\_col function} To remove the legend title, we used the `name=NULL` argument inside the `scale_fill_discrete()` function. We also decided to modify the group labels, but one important detail arose: the scientific names. To solve this, we used the `ggtext` library, which allows for easy Markdown and HTML representation for ggplot2. Using the `element_markdown()` argument of this package, the text is displayed without automatic line wrapping, and a `<br>` is used to start a new line. Additionally, asterisks are placed on both sides of the scientific name to make it appear in *italics*.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(ggtext)

m + geom_col() +
  scale_fill_discrete(name=NULL) +
  scale_x_discrete(breaks=c("NonDiarrhealControl",
                            "DiarrhealControl",
                            "Case"),
  labels=c("Healthy",
            "Diarrhea,<br>*C. difficile*<br>negative",
            "Diarrhea,<br>*C. difficile*<br>positive")) +
  scale_y_continuous(expand = c(0, 0)) +
  labs(x=NULL,
       y="Mean Relative Abundance (%)") +
  theme_us_classic() +
  theme(axis.text.x = element_markdown(),
        legend.text = element_text(face = "italic"),
        legend.key.size = unit(10, "pt"))

```

It is clear that a stacked bar chart has several shortcomings. In this example, although we have worked only at the *phylum* level, it is difficult to compare the study groups. In addition, the wide range of colors distracts from the main objective, which is to interpret the data. Because of these drawbacks, I do not consider this type of visualization as one of my favorites.

(ref:stackedbar2) Stacked bar plot representing the relative abundance of bacterial phyla in the different experimental groups. Note: To generate this graph we used the code published by Riffomonas Professional Development [@Schloss2023].

```{r stackedbar2, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:stackedbar2)',fig.align='center'}

library(pacman)
pacman::p_load(
        tidyverse,
        ggtext,
        scales,
        RColorBrewer)

microbiome_otu <- read.csv(
                  "data/Chapter06/microbiome_otu",
                  header=T, stringsAsFactors=FALSE)
phylum_data <- microbiome_otu %>% 
           filter(level == "phylum") %>%
group_by(disease_stat,sample_id, taxon) %>%
summarise(abun_rela = sum(abun_rela)) %>%
group_by(disease_stat, taxon) %>%
summarise(mean_abun_rela = 100*mean(abun_rela),
          .groups = "drop") %>%
mutate(disease_stat = factor(disease_stat,
levels = c("NonDiarrhealControl",
"DiarrhealControl", "Case"))) %>%
mutate(taxon = str_replace(taxon,
"(.*)_unclassified", "Unclassified *\\1*"))

pool_tax = phylum_data %>%
           group_by(taxon) %>%
           summarize(pool = max(mean_abun_rela) < 3,
            mean = mean(mean_abun_rela),
            .groups="drop")

m2 <- inner_join(phylum_data, pool_tax, by="taxon") %>%
     mutate(taxon = if_else(pool, "Other", taxon)) %>%
     group_by(disease_stat, taxon) %>%
     summarize(mean_abun_rela = sum(mean_abun_rela),
            mean = min(mean),
            .groups="drop") %>%
     mutate(taxon = factor(taxon),
         taxon = fct_reorder(taxon, mean, .desc=TRUE),
         taxon = fct_shift(taxon, n=1))
m2 %>% 
  ggplot(aes(x=disease_stat, 
                           y=mean_abun_rela, fill=taxon)) +
  geom_col(width = 0.7) +
  scale_fill_discrete(name=NULL) +
  scale_fill_manual(name=NULL,
              breaks=c( "Bacteroidetes", 
                        "Proteobacteria",
                        "Verrucomicrobia",
                        "Other",
                        "Firmicutes"),
              values = c(
            "#56B4E9", "#E69F00", "#009E73",
             "gray40", "#CC79A7"
              )) +
  scale_x_discrete(breaks=c("NonDiarrhealControl",
                            "DiarrhealControl",
                            "Case"),
  labels=c("Healthy",
            "Diarrhea,<br>*C. difficile*<br>negative",
            "Diarrhea,<br>*C. difficile*<br>positive")) +
  scale_y_continuous(expand = c(0, 0),
                     labels = scales::percent_format(
        accuracy = 1, scale = 1)) +
  labs(x=NULL,
       y="Mean Relative Abundance (%)") +
  theme_us_classic() +
  theme(axis.text.x = element_markdown(),
        legend.text = element_text(face = "italic"),
        legend.key.size = unit(10, "pt"),
        plot.margin = margin(14, 7, 3, 1.5))

```

Despite these disadvantages, it is possible to improve this type of visualization. A first step would be to reduce the number of taxonomic levels, highlighting those of higher relative abundance and grouping the remaining ones in the `Others` category, which will include those of relative abundance less than 3% (Figure \@ref(fig:stackedbar2)).

```{r, warning=FALSE, message=FALSE, error=FALSE}

pool_tax = phylum_data %>%
           group_by(taxon) %>%
           summarize(pool = max(mean_abun_rela) < 3,
            mean = mean(mean_abun_rela),
            .groups="drop")

m2 <- inner_join(phylum_data, pool_tax, by="taxon") %>%
     mutate(taxon = if_else(pool, "Other", taxon)) %>%
     group_by(disease_stat, taxon) %>%
     summarize(mean_abun_rela = sum(mean_abun_rela),
            mean = min(mean),
            .groups="drop") %>%
     mutate(taxon = factor(taxon),
         taxon = fct_reorder(taxon, mean, .desc=TRUE),
         taxon = fct_shift(taxon, n=1))

```

With these modifications, we will show our new graph. As you can see, the comparison between the bacterial phyla of the different groups is much clearer and understandable. We also set the order of these bacteria using the `fct_reorder(.desc=TRUE)` argument. Reducing the number of bacteria to four and a relative abundance group < 3% (Others) will allow us to use a qualitative color scale, such as the **Okabe-Ito** color palette (Section \@ref(qualitative-color)).

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(ggtext)
library(scales)

m2 %>% 
  ggplot(aes(x=disease_stat, 
                           y=mean_abun_rela, fill=taxon)) +
  geom_col(width = 0.7) +
  scale_fill_discrete(name=NULL) +
  scale_fill_manual(name=NULL,
              breaks=c( "Bacteroidetes", 
                        "Proteobacteria",
                        "Verrucomicrobia",
                        "Other",
                        "Firmicutes"),
              values = c(
            "#56B4E9", "#E69F00", "#009E73",
             "gray40", "#CC79A7"
              )) +
  scale_x_discrete(breaks=c("NonDiarrhealControl",
                            "DiarrhealControl",
                            "Case"),
  labels=c("Healthy",
            "Diarrhea,<br>*C. difficile*<br>negative",
            "Diarrhea,<br>*C. difficile*<br>positive")) +
  scale_y_continuous(expand = c(0, 0),
                     labels = scales::percent_format(
        accuracy = 1, scale = 1)) +
  labs(x=NULL,
       y="Mean Relative Abundance (%)") +
  theme_us_classic() +
  theme(axis.text.x = element_markdown(),
        legend.text = element_text(face = "italic"),
        legend.key.size = unit(10, "pt"),
        plot.margin = margin(14, 7, 3, 1.5))

```

As you can see, the intestinal microbiota of hospitalized individuals with and without *Clostridium difficile* infections (CDI) who developed diarrhea, present variations in bacterial phyla compared to healthy individuals.

**A suggestion:** The titles of the axes represent the values expressed in the data. In the example above, the y-axis title indicates "mean relative abundance (%)". Although it was already indicated that the values are in percent, reinforcing this information may be useful to the reader. Therefore, the `%` symbols were added to the y-axis text using the `percent_format()` argument of the scales package [@scales2].

### Horizontal - One or more series {#bar-plot-horizontal}

The horizontal bar plot is very easy to interpret. This type of chart is ideal for categories with long names, as it allows a more compact and orderly display. \index{Bar plot!horizontal}

```{r barstudy, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "A bar-plot representation of awareness on environmental issues. Bar plot representation of awareness of environmental issues. Labels are rotated, making them difficult to read and requiring wasteful use of space below the graphic.",fig.align='center'}

library(tidyverse)
library(readxl)

environmental <- read_xlsx(path = 
         "data/Chapter06/environmental_issues.xlsx",
         col_names = TRUE)

ev <- ggplot(environmental, aes(
                           x = environmental_issues,
                           y= percentage,
                           fill = types_response))

color_palette <- c(
  "Agree" = "#0570b0",
  "Disagree" = "#74a9cf"
)

ev + geom_col(position = "dodge") +
     labs(y = "Percentage of response",
          x = NULL) +
     scale_fill_manual(
          values = color_palette,
          name = NULL) +
     scale_y_continuous(expand = c(0,0),
                        limits = c(0,100)) +
     theme_us_classic() + 
     theme(axis.text.x = element_text(
                             angle = 45,
                             hjust = 1,
                             vjust = 1),
           legend.title = element_blank(),
           plot.margin = margin(18, 6, 3, 1.5))

```

We will use a data set from a survey on the level of environmental knowledge and awareness conducted among 150 farmers in three Indian states (Rajasthan, Telangana and Andhra Pradesh), located in similar agro-ecological zones [@Aakanksha20].

```{r, error=FALSE, message=FALSE, warning=FALSE}

library(readxl)

environmental <- read_xlsx(path = 
         "data/Chapter06/environmental_issues.xlsx",
         col_names = TRUE)
head(environmental, 4)
```

After entering our data, we will make our graph published in the study (Figure \@ref(fig:barstudy)).

```{r, warning=FALSE, message=FALSE, error=FALSE}

ev <- ggplot(environmental, aes(
                           x = environmental_issues,
                           y= percentage,
                           fill = types_response))
```

As can be seen in the graphic, the vertical bar labels are long, and a possible solution would be to tilt them at 45 degrees using the `angle = 45` argument. Although I have seen this practice in many publications, I personally do not think it is the best option, as the labels are difficult to read (forcing you to turn your head) and it wastes space below the graphic. Another alternative, less common but seen in some publications, is to rotate the labels vertically, this option is even less aesthetically pleasing.

```{r barhorizontal, fig.width = 7., fig.asp = .7,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "Horizontal bar plot of awareness of environmental issues.",fig.align='center'}

library(readxl)
library(tidyverse)
library(scales)

environmental <- read_xlsx(path = 
         "data/Chapter06/environmental_issues.xlsx",
         col_names = TRUE) %>%
         mutate(
         environmental_issues = factor(environmental_issues),
         environmental_issues = fct_rev(environmental_issues))

ev <- ggplot(environmental, aes(
        x = environmental_issues,
        y= percentage,
        fill = types_response))

color_palette <- c(
  "Agree" = "#0570b0",
  "Disagree" = "#74a9cf"
)

ev + geom_col(position = "dodge") +
     labs(y = "Percentage of response",
          x = NULL) +
     scale_fill_manual(limits = c("Disagree", "Agree"),
          values = color_palette, 
                  name = NULL) +
     scale_y_continuous(expand = c(0,0), limits = c(0,100),
      position = "right", labels = scales::percent_format(
        accuracy = 1, scale = 1)) +
     coord_flip() +
     theme_us_classic() + 
     theme(legend.title = element_blank(),
           axis.title.x = element_text(hjust = 0),
           legend.position = "right",
           legend.justification.right= "top",
           plot.margin = margin(4, 4, 0.1, 0.1))

```


```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

color_palette <- c(
  "Agree" = "#0570b0",
  "Disagree" = "#74a9cf"
)
ev + geom_col(position = "dodge") +
     labs(y = "Percentage of response",
          x = NULL) +
     scale_fill_manual(
          values = color_palette,
          name = NULL) +
     scale_y_continuous(expand = c(0,0),
                        limits = c(0,100)) +
     theme_us_classic() + 
     theme(axis.text.x = element_text(
                             angle = 45,
                             hjust = 1,
                             vjust = 1),
           legend.title = element_blank())

```

An effective solution for long labels is to rotate the entire chart using the `coord_flip()` function. This orients the bars horizontally, maintaining their main visual attribute (length), but with the labels arranged horizontally. This action, Figure \@ref(fig:barhorizontal) is much easier to read than the previous Figure \@ref(fig:barstudy).

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

environmental <- read_xlsx(path = 
         "data/Chapter06/environmental_issues.xlsx",
         col_names = TRUE) %>%
         mutate(
         environmental_issues = factor(environmental_issues),
         environmental_issues = fct_rev(environmental_issues))

ev <- ggplot(environmental, aes(
        x = environmental_issues,
        y= percentage,
        fill = types_response))

ev + geom_col(position = "dodge") +
     labs(y = "Percentage of response",
          x = NULL) +
     scale_fill_manual(limits = c("Disagree", "Agree"),
          values = color_palette, 
                  name = NULL) +
     scale_y_continuous(expand = c(0,0), limits = c(0,100),
      position = "right", labels = scales::percent_format(
        accuracy = 1, scale = 1)) +
     coord_flip() +
     theme_us_classic() + 
     theme(legend.title = element_blank(),
           axis.title.x = element_text(hjust = 0),
           legend.position = "right",
           legend.justification.right= "top")

```

An additional adjustment we can make to our graph is to move the Y-axis to the right, using the `position = “right”` argument. This choice is based on the way we normally process information, starting from the top.

Taking advantage of this data, creating a stacked horizontal bar plot can generate a fairly clear visualization as well. This visualization provides a uniform baseline on both the far left and far right, which improves readability. In addition, this type of graph is commonly used in surveys that employ Likert scales (Figure \@ref(fig:stackedbar3)).

```{r stackedbar3,fig.width = 7., fig.asp = .7,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "100% stacked horizontal bar plot showing farmers' awareness of environmental issues.",fig.align='center'}

library(scales)
library(readxl)
library(tidyverse)

environmental <- read_xlsx(path = 
         "data/Chapter06/environmental_issues.xlsx",
         col_names = TRUE) %>%
         mutate(
         environmental_issues = factor(environmental_issues),
         environmental_issues = fct_rev(environmental_issues))

ev <- ggplot(environmental, aes(
        x = environmental_issues,
        y= percentage,
        fill = types_response))

color_palette <- c(
  "Agree" = "#0570b0",
  "Disagree" = "#74a9cf"
)

ev + geom_col(color = "white") +
     geom_hline(
      yintercept = c(50),
      color = "gray20", size = 0.6, 
      linetype = 2) +
    geom_hline(yintercept = 100, color = "black") +
     labs(y = "Percentage of response",
          x = NULL) +
     scale_fill_manual(limits = c("Disagree", "Agree"),
          values = color_palette, 
                  name = NULL) +
     scale_y_continuous(expand = c(0,0),
                    limits = c(0,100),
                    position = "right",
                    labels = scales::percent_format(
                      accuracy = 1, scale = 1)) +
     coord_flip() +
     theme_us_classic() + 
     theme(legend.title = element_blank(),
           legend.position = "right",
           legend.justification.right= "top",
           axis.title.x = element_text(hjust = 0),
           axis.line.x = element_blank(),
           plot.margin = margin(18, 6, 3, 1.5))

```

Some additional modifications were to remove the y-axis line using the `axis.line.x = element_blank()` argument, and to make it easier for the reader to identify lesser known environmental problems, a dashed horizontal line was added at 50%.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

ev + geom_col(color = "white") +
     geom_hline(
      yintercept = c(50),
      color = "gray20", size = 0.6, 
      linetype = 2) +
    geom_hline(yintercept = 100, color = "black") +
     labs(y = "Percentage of response",
          x = NULL) +
     scale_fill_manual(limits = c("Disagree", "Agree"),
          values = color_palette, 
                  name = NULL) +
     scale_y_continuous(expand = c(0,0),
                    limits = c(0,100),
                    position = "right",
                    labels = scales::percent_format(
                      accuracy = 1, scale = 1)) +
     coord_flip() +
     theme_us_classic() + 
     theme(legend.title = element_blank(),
           legend.position = "right",
           legend.justification.right= "top",
           axis.title.x = element_text(hjust = 0),
           axis.line.x = element_blank())
```

The plot shows a general lack of awareness among farmers about issues such as biodiversity and habitat loss, water pollution, the use of genetically modified organisms, climate change and the generation of agricultural waste. However, most farmers are well informed about water depletion, soil degradation, the harmful effects of chemical fertilizers and pesticides, as well as air pollution.

```{block2, barp, type='rmdtip'}

__Want to know more?__

- In Figure \@ref(fig:barhorizontal) and \@ref(fig:stackedbar3) the order of the x-axis was inverted using the `fct_rev()` function of the forcats package. Also in these figures the order of the legend labels was changed manually using the argument `limits = c()`, however there is another way to perform the inversion and that is by executing `guide = guide_legend(reverse = TRUE)`.
- The `sprintf()` function is useful for formatting text and variables. 
- The `paste0` function allows us to add the percentage symbol to the numbers.
- You can remove the legend using the `guides()` function and the argument fill=FALSE.
- Another way to remove the legend is to use the function `scale_fill_discrete(guide = FALSE)`.

```

## Pie chart {#pie-chart}

This type of chart is familiar to many people, but it is also one of the most criticized and misused. \index{Pie chart} The main criticism is that pie charts are an unsuitable choice for visualization, as it is difficult to perceive exact quantities when they are represented as slices of a pie [@Schwabish20]. 

```{r piechart0, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "The main rule of pie charts is that the segments must add up to 100%.",fig.align='center'}
library(cowplot)
library(scales)
library(tidyverse)

d <- data.frame(col1 = c(35,62,80,22), 
                 col2 = c("D", "C", "B", "A")) %>% 
  dplyr::mutate(col2 = factor(col2, levels = LETTERS[1:4]), 
         cf = cumsum(col1), 
         mid = cf - col1/3, 
         label = paste0(col2, ":", 
         round(col1 /sum(col1)* 100, 0), "%")) 

pie_chart <- ggplot(d, aes(x = 1, y = col1, 
                    fill = col2)) +
            geom_bar(width = 1, stat = "identity", color = "white",
                     size = 1) +
            coord_polar("y",start = 4) + 
            geom_text(aes(x = 1.18, y = mid, label = label),
                      size = 4.3, color = "white") +
            scale_fill_manual(values=c("gray50", "#42598a", "#D55E00", "#009E73")) +
            labs(x = "", y = "", title = "Pie chart") +
            theme_void() + 
            theme(legend.position = "none",
                  plot.title = element_text(hjust = 0.5,
                                            size = 19),
                  plot.margin = margin(3.5, 1.5, 3.5, 1.5))
pie_chart

```
 
Pie charts are useful for showing how data is divided into parts of a whole, i.e., each slice represents a component and the sum of all slices equals the total. Also, this type of chart is suitable when working with very small data sets. Finally, another utility of this chart is that it can avoid the illusion of sequence that sometimes arises with the order of the bars in a bar plot, whether this sequence was intentional or not [@RIFFENBURGH2].In biology, pie charts are commonly used in areas of epigenetics and in the proportional representation of the bacterial population present at a given time (microbiome). 

(ref:piechart1) Pie chart showing representing the relative abundance (%) of bacterial phyla in the different experimental groups.Note: To generate this graph we used the code published by Riffomonas Professional Development [@Schloss2023].

```{r piechart1, fig.width = 5.4*6/5, fig.asp = 0.7, dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:piechart1)',fig.align='center'}
library(ggtext)
library(RColorBrewer)
library(scales)
library(tidyverse)
library(ggrepel)
microbiome_otu <- read.csv(
                  "data/Chapter06/microbiome_otu",
                  header=T, stringsAsFactors=FALSE)
phylum_data <- microbiome_otu %>% 
           dplyr::filter(level == "phylum") %>%
dplyr::group_by(disease_stat,sample_id, taxon) %>%
dplyr::summarise(abun_rela = sum(abun_rela)) %>%
dplyr::group_by(disease_stat, taxon) %>%
dplyr::summarise(mean_abun_rela = 100*mean(abun_rela),
          .groups = "drop") %>%
dplyr::mutate(disease_stat = factor(disease_stat,
levels = c("NonDiarrhealControl",
"DiarrhealControl", "Case"))) %>%
dplyr::mutate(taxon = str_replace(taxon,
"(.*)_unclassified", "Unclassified *\\1*"))

pool_tax = phylum_data %>%
           dplyr::group_by(taxon) %>%
           dplyr::summarize(pool = max(mean_abun_rela) < 4,
            mean = mean(mean_abun_rela),
            .groups="drop")

labels_group = c(
"NonDiarrhealControl" = "Healthy",
"DiarrhealControl" = "Diarrhea,<br>*C. difficile*<br>negative",
"Case" = "Diarrhea,<br>*C. difficile*<br>positive")


m2 = dplyr::inner_join(phylum_data, pool_tax, by="taxon") %>%
     dplyr::mutate(taxon = if_else(pool, "Other", taxon)) %>%
     dplyr::group_by(disease_stat, taxon) %>%
     dplyr::summarize(mean_abun_rela = sum(mean_abun_rela),
            mean = min(mean),
            .groups="drop") %>%
     dplyr::mutate(taxon = factor(taxon),
         taxon = fct_reorder(taxon, mean, .desc=TRUE),
         taxon = fct_shift(taxon, n=1))
m2 %>% 
  ggplot(aes(x=1, y=mean_abun_rela, fill=taxon)) +
  geom_col(color = "white",size = 1, width = 1) +
  coord_polar(theta = "y", start = 0) + 
  geom_text(aes(label = paste0(round(mean_abun_rela),"%"), 
    x=1.68),position = position_stack(vjust = 0.5),
    color = "black", size = unit(3.2,"mm"))+
  facet_wrap(~disease_stat, ncol = 3,
             labeller = labeller(disease_stat = labels_group)) +
  scale_fill_discrete(name=NULL) +
  scale_fill_manual(name=NULL,
              breaks=c( "Bacteroidetes",
                        "Firmicutes",
                        "Other",
                        "Proteobacteria"),
              values = c("#D55E00","#15617b",
                         "#bfbfbf","#009E73")) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(breaks = NULL) +
  labs(x=NULL,
       y="Mean Relative Abundance (%)") +
  theme_void() +
  theme(legend.text = element_text(face = "italic",
                        size = 12),
        legend.position = "inside",
        legend.position.inside = c(0.35,0),
        legend.direction = "horizontal",
        legend.key.size = unit(12, "pt"),
        strip.text = element_markdown(size = 14),
        plot.margin = margin(3.5, 1.5, 3.5, 1.5))

```


We will use the data set from Section \@ref(stacked-bar-plot) of this chapter. Before plotting, the variable `pool` will include the relative abundance below 4%, including those bacterial groups to the `Other` group. 

```{r, error=FALSE, message=FALSE, warning=FALSE}

pool_tax <- phylum_data %>%
           group_by(taxon) %>%
           summarize(pool = max(mean_abun_rela) < 4,
            mean = mean(mean_abun_rela),
            .groups="drop")

m2 <- inner_join(phylum_data, pool_tax, by="taxon") %>%
     mutate(taxon = if_else(pool, "Other", taxon)) %>%
     group_by(disease_stat, taxon) %>%
     summarize(mean_abun_rela = sum(mean_abun_rela),
            mean = min(mean),
            .groups="drop") %>%
     mutate(taxon = factor(taxon),
         taxon = fct_reorder(taxon, mean, .desc=TRUE),
         taxon = fct_shift(taxon, n=1))

```

Then we will create a variable called `labels_group`, in order to use it as titles for our pie charts.

```{r, error=FALSE, message=FALSE, warning=FALSE}
labels_group = c(
"NonDiarrhealControl" = "Healthy",
"DiarrhealControl" = "Diarrhea,<br>*C. difficile*<br>negative",
"Case" = "Diarrhea,<br>*C. difficile*<br>positive")
```

There is no geom_ function that allows you to create a pie chart directly. However, it is possible to do it ingeniously. Once you have the data ready, first create a bar chart with the `geom_col()` function and then convert it to pie using `coord_polar(“y”, start = 0)`. \index{coord\_polar function} To label the percentages and adjust their position, use `position_stack(vjust = 0.5)` within the `geom_text()` function. In addition, for each group, a pie chart was created using `facet_wrap()`. Finally, the legend was left off and placed at the bottom with the argument `legend.position = “bottom”`, avoiding labeling directly on the graphs so as not to overload the visualization. 

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}
library(ggtext)
library(scales)

m2 %>% 
  ggplot(aes(x=1, y=mean_abun_rela, fill=taxon)) +
  geom_col(color = "white",size = 1, width = 1) +
  coord_polar(theta = "y", start = 0) + 
  geom_text(aes(label = paste0(round(mean_abun_rela),"%"), 
    x=1.68),position = position_stack(vjust = 0.5),
    color = "black", size = unit(3.2,"mm"))+
  facet_wrap(~disease_stat, ncol = 3,
             labeller = labeller(disease_stat = labels_group)) +
  scale_fill_discrete(name=NULL) +
  scale_fill_manual(name=NULL,
              breaks=c( "Bacteroidetes",
                        "Firmicutes",
                        "Other",
                        "Proteobacteria"),
              values = c("#D55E00","#15617b",
                         "#bfbfbf","#009E73")) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(breaks = NULL) +
  labs(x=NULL,
       y="Mean Relative Abundance (%)") +
  theme_void() +
  theme(legend.text = element_text(face = "italic",
                        size = 12),
        legend.position = "inside",
        legend.position.inside = c(0.35,0),
        legend.direction = "horizontal",
        legend.key.size = unit(12, "pt"),
        strip.text = element_markdown(size = 14),
        plot.margin = margin(3.5, 1.5, 3.5, 1.5))

```

Here are some tips for creating an effective pie chart:

- Avoid using **3D pie charts**, as in addition to the difficulty in comparing proportions, you introduce clutter and distortion in the data.

- Avoid including too many proportions; ideally, use pie charts with small data sets.

- Arrange the portions of your graph, placing the largest to the right of 12 o'clock, the second largest to the left, and the others counterclockwise, in descending order.

- Directly label values and legends on the graph for clarity.

- Use color strategically, using different shades to highlight one or two important portions.

## Lollipop plot {#lollipop-plot}

The lollipop plot is essentially a version of a bar plot, where the bar is replaced by a line and a dot. \index{Lollipop plot} This type of chart is useful when several bars have similar heights, making it difficult to compare variables (Figure \@ref(fig:lollipop1)). It also consumes less ink and provides more white space, making it easier to add labels or other annotations.

```{r lollipop1,  fig.width = 7., fig.asp = .9,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "Pairwise combinations of 65 drugs belonging to various chemical classes and targeting different cellular processes. Shown in the form of bars.", fig.align='center'}

library(RColorBrewer)
library(readxl)
library(tidyverse)

drug <- read_xlsx(path = 
         "data/Chapter06/drug_combinations.xlsx",
         col_names = TRUE, sheet = "Fig.1a")

d <- drug %>%
    dplyr::arrange(Count) %>%
    dplyr::mutate(Class2 = factor(Class,
           levels = c("beta-lactams",
                    "glycopeptides and lipopeptides",
                    "other cell wall","membrane",
                    "oxidative stress/PMF",
                     "DNA/oxidative stress",
                     "fluoroquinolones",
                     "folate biosynthesis",
                     "other DNA",
                    "macrolides and ketolides",
                     "tetracyclines",
                     "aminoglycosides",
                      "lincosamides",
                      "streptogramins",
                      "oxazolidinones",
                      "other protein synthesis",
                       "protein degradation",
                      "non-antibiotic"))) %>%
  ggplot(aes(x = Class2, y = Count))


d + geom_col(aes(fill = Targeted_process)) +
    ylim(0, max(drug$Count)) +
    scale_fill_manual(values =c(
                        brewer.pal(6, "Dark2"), 
                           "dodgerblue3")) + 
    xlab(NULL) +
    scale_x_discrete(limits = rev) +
    scale_y_continuous(expand = c(0,0),
    breaks = c(0,2.5,5,7.5,10), 
    labels = c("0","2.5","5","7.5","10")) +
    coord_flip() +
    theme_us_classic() +
    theme(legend.title = element_blank(),
    axis.title.x = element_text(hjust = 0),
    legend.key.size = unit(12, "pt"),
    legend.position = "right",
    legend.justification.right = c(0,1),
    plot.margin = margin(18, 6, 3, 1.5))


```

In the following, we will employ a data set analyzing approximately 8000 combinations of 65 antibacterial drugs against the model species *Bacillus subtilis* and two important pathogens: *Staphylococcus aureus* and *Streptococcus pneumoniae* [@Cacace2023]. They analyzed a set of 65 drugs, which included 57 antibiotics used to treat Gram-positive bacterial infections. These antibiotics spanned all major classes and targeted different bacterial processes. In addition, they included eight other bioactive molecules, such as antifungals, human-targeting drugs and food additives, categorized as non-antibiotics.

```{r lollipop2,  fig.width = 7., fig.asp = .9, dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "Pairwise combinations of 65 drugs belonging to various chemical classes and targeting different cellular processes. Shown in the form of lollipops.", fig.align='center'}

library(RColorBrewer)
library(readxl)
library(tidyverse)

drug <- read_xlsx(path = 
         "data/Chapter06/drug_combinations.xlsx",
         col_names = TRUE, sheet = "Fig.1a")

d <- drug %>%
    dplyr::arrange(Count) %>%
    dplyr::mutate(Class2 = factor(Class,
           levels = c("beta-lactams",
                    "glycopeptides and lipopeptides",
                    "other cell wall","membrane",
                    "oxidative stress/PMF",
                     "DNA/oxidative stress",
                     "fluoroquinolones",
                     "folate biosynthesis",
                     "other DNA",
                    "macrolides and ketolides",
                     "tetracyclines",
                     "aminoglycosides",
                      "lincosamides",
                      "streptogramins",
                      "oxazolidinones",
                      "other protein synthesis",
                       "protein degradation",
                      "non-antibiotic"))) %>%
  ggplot(aes(x = Class2, y = Count))

d + geom_segment(aes(x = Class2,
      xend = Class2, y = 0, yend = Count),
      lwd = 1, color = "gray50") +
    geom_point(aes(color =Targeted_process),
               size = 4) + 
    ylim(0, max(drug$Count)) +
    scale_color_manual(values =c(
                        brewer.pal(6, "Dark2"), 
                           "dodgerblue3")) + 
    xlab(NULL) +
    scale_x_discrete(limits = rev) +
    scale_y_continuous(expand = c(0,0),
    limits = c(0,11),
    breaks = c(0,2.5,5,7.5,10), 
    labels = c("0","2.5","5","7.5","10")) +
    coord_flip() +
    theme_us_classic() +
    theme(legend.title = element_blank(),
    axis.title.x = element_text(hjust = 0),
    legend.key.size = unit(12, "pt"),
    legend.background = element_rect(
      fill = "transparent",color = NA),
    legend.position = "right",
    legend.justification.right = c(0,1),
    plot.margin = margin(18, 6, 3, 1.5))


```

After entering our data and specifying the spreadsheet with the `sheet` argument, we perform certain maneuvers to obtain the following Figure \@ref(fig:lollipop2). 

```{r, error=FALSE, message=FALSE, warning=FALSE}

library(readxl)

drug <- read_xlsx(path = 
         "data/Chapter06/drug_combinations.xlsx",
         col_names = TRUE, sheet = "Fig.1a")
```

We will create the `Class2` variable with the desired order for the groups. First, we will use the `arrange()` function to arrange the data set, and then we will use the `factor(levels)` argument within the `mutate()` function to set a custom order for the factor, specifying the levels individually. \index{arrange function}

```{r, warning=FALSE, message=FALSE, error=FALSE}

d <- drug %>%
    arrange(Count) %>%
    mutate(Class2 = factor(Class,
           levels = c("beta-lactams",
                    "glycopeptides and lipopeptides",
                    "other cell wall","membrane",
                    "oxidative stress/PMF",
                     "DNA/oxidative stress",
                     "fluoroquinolones",
                     "folate biosynthesis",
                     "other DNA",
                    "macrolides and ketolides",
                     "tetracyclines",
                     "aminoglycosides",
                      "lincosamides",
                      "streptogramins",
                      "oxazolidinones",
                      "other protein synthesis",
                       "protein degradation",
                      "non-antibiotic"))) %>%
  ggplot(aes(x = Class2, y = Count))

```

There is no specific function in *ggplot2* to create this type of plot. The trick is to combine `geom_point()` for points and `geom_segment()` for lines. Finally, the plot is rotated using `coord_flip()`.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(RColorBrewer)

d + geom_segment(aes(x = Class2,
      xend = Class2, y = 0, yend = Count),
      lwd = 1, color = "gray50") +
    geom_point(aes(color =Targeted_process),
               size = 4) + 
    ylim(0, max(drug$Count)) +
    scale_color_manual(values =c(
                        brewer.pal(6, "Dark2"), 
                           "dodgerblue3")) + 
    xlab(NULL) +
    scale_x_discrete(limits = rev) +
    scale_y_continuous(expand = c(0,0),
    limits = c(0,11),
    breaks = c(0,2.5,5,7.5,10), 
    labels = c("0","2.5","5","7.5","10")) +
    coord_flip() +
    theme_us_classic() +
    theme(legend.title = element_blank(),
    axis.title.x = element_text(hjust = 0),
    legend.key.size = unit(12, "pt"),
    legend.background = element_rect(
      fill = "transparent",color = NA),
    legend.position = "right",
    legend.justification.right = c(0,1),
    plot.margin = margin(18, 6, 3, 1.5))

```

The plot has a major disadvantage: it is not entirely clear which part of the circle represents the value. In addition, making accurate comparisons can be tricky, especially when the circles are large or of unequal sizes, so it is important to be careful when adjusting the size of the points.


## Cleveland Dot plot {#dotplot}

This plot, developed by William Cleveland, is an alternative to paired or stacked bar plots. Dot plots represent individual data with circles along the x or y axis, overcoming the limitation of bars that must start at zero. \index{Dot plot} In addition, they offer more space to add annotations (such as data values) next to, above or inside each circle.

This time, we will create a connected dot plot. It works similarly to the Cleveland dot plot, but represents two (or more) data series connected by lines. This type of plot is especially useful for showing comparisons between groups. The Figure \@ref(fig:dotplot) presents a survey on the intention to vaccinate against COVID-19, conducted by [Ipsos](https://www.ipsos.com/en/global-attitudes-covid-19-vaccine-october-2020) from October 8-13, 2020.

(ref:dotplot) If a vaccine for Covid-19 were available, I would get it. Shown as a connected dot plot is the Ipsos survey of more than 18,000 adults in 15 countries. Note: To generate this graph we used the code published by Riffomonas Professional Development [@Schloss2023].

```{r dotplot, fig.width = 5*6/4.2, fig.asp = 4.9*(0.12+1+.07)/7, dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:dotplot)',fig.align='center'}

library(ggtext)
library(glue)
vaccine <- read.csv(
  file = "data/Chapter06/data-8KmKL.csv", 
  header = TRUE
  ) %>%
  dplyr::rename(Country = X.1,
         Percent_august = "Total.Agree...August.2020",
         Percent_october = "Total.Agree...October.2020") %>%
  dplyr::mutate(Label_august = 
           if_else(Percent_august < Percent_october,
                   Percent_august - 3,
                   Percent_august + 3),
         Label_october = 
           if_else(Percent_august < Percent_october,
                   Percent_october + 3,
                   Percent_october - 3))
vaccine2 <- vaccine %>%
           tidyr::pivot_longer(cols = -Country, 
                names_to=c(".value","Month"),
                names_sep = "_") %>%
           dplyr::mutate(Country = factor(Country, 
                  levels = rev(vaccine$Country))) 

v = ggplot(vaccine2, aes(x = Percent,
                         y = Country,
                         color = Month))

v + geom_line(color="#e6e6e6", 
              size=1.75) +
  geom_point(size=3) + 
  labs(x=NULL, y=NULL) +
  geom_text(aes(label=glue("{Percent}%"), x=Label),
            size=3.5, show.legend = FALSE) +
  scale_x_continuous(limits=c(50, 100),
                breaks=seq(50, 100, by=5),
                labels=glue("{seq(50, 100, 5)}%")) +
  scale_color_manual(name=NULL,
                breaks=c("august", "october"),
                values=c("#727272", "#15617b"),
                labels=c("Total agree - \nAugust 2020", 
                         "Total agree - \nOctober 2020"),
  guide = guide_legend(reverse = TRUE)) +
  theme_us_classic() +
  theme(axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_text(color="gray50"),
        legend.position = "top",
        legend.justification = "left",
        legend.key = element_blank(),
        plot.margin = margin(4, 4, 0.1, 0.1))

```

When loading our data, it is necessary to make some adjustments. First, we will use the `rename()` function to change the variable names. Next, we will create the variables `Label_august` and `Label_october`, which will contain the values of the August and October surveys, respectively. This will allow us to label the values in our plot appropriately.

```{r, error=FALSE, message=FALSE, warning=FALSE}

vaccine <- read.csv(
  file = "data/Chapter06/data-8KmKL.csv", 
  header = TRUE
  ) %>%
  rename(Country = X.1,
         Percent_august = "Total.Agree...August.2020",
         Percent_october = "Total.Agree...October.2020") %>%
  mutate(Label_august = 
           if_else(Percent_august < Percent_october,
                   Percent_august - 3,
                   Percent_august + 3),
         Label_october = 
           if_else(Percent_august < Percent_october,
                   Percent_october + 3,
                   Percent_october - 3))

```

After creating the new variables, the number of rows was increased and the number of columns was reduced using the `pivot_longer()` function. Finally, the values were arranged in descending order by using the `rev()` argument. \index{pivot\_longer function}

```{r, warning=FALSE, message=FALSE, error=FALSE}

vaccine2 <- vaccine %>%
           pivot_longer(cols = -Country, 
                names_to=c(".value","Month"),
                names_sep = "_") %>%
           mutate(Country = factor(Country, 
                  levels = rev(vaccine$Country))) 

head(vaccine2,4)
```

We will create our chart and fill in our points according to the months of August and October. 

```{r, warning=FALSE, message=FALSE, error=FALSE}

v <- ggplot(vaccine2, aes(x = Percent,
                         y = Country,
                         color = Month))

```


First we will plot the lines with `geom_line()` and then our points with `geom_point()`. \index{geom\_line function} Then we will add our values in percentages using the `glue()` function from the package of the same name. \index{geom\_point function} 

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(ggtext)
library(glue)

v + geom_line(color="#e6e6e6", 
              size=1.75) +
  geom_point(size=3) + 
  labs(x=NULL, y=NULL) +
  geom_text(aes(label=glue("{Percent}%"), x=Label),
            size=3.5, show.legend = FALSE) +
  scale_x_continuous(limits=c(50, 100),
                breaks=seq(50, 100, by=5),
                labels=glue("{seq(50, 100, 5)}%")) +
  scale_color_manual(name=NULL,
                breaks=c("august", "october"),
                values=c("#727272", "#15617b"),
                labels=c("Total agree - \nAugust 2020", 
                         "Total agree - \nOctober 2020"),
      guide = guide_legend(reverse = TRUE)) +
  theme_us_classic() +
  theme(axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_text(color="gray50"),
        legend.position = "top",
        legend.justification = "left",
        legend.key = element_blank())

```

The main disadvantage of dot plots is that they are not suitable for large data sets, as they quickly become confusing and disorganized. In addition, identifying the mean and median can be complicated when analyzing a dot plot.

## Box plot {#boxplot}

Box plots, also known as box-and-whisker plots, are simple but powerful graphs that allow you to visualize the distribution of data and compare them between your variables. \index{Box plot}  This diagram, created by John W. Tukey, uses a box and lines (*whiskers*) representing specific percentiles within a distribution [@Krzywinski20]. 

```{r boxplot0, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "The main components of a boxplot. Notched box plot (left) and traditional box plot (right). Both show a line representing the median in the center of the box, which encompasses 50% of the data. The upper and lower whiskers extend to the maximum and minimum values. Data points beyond the boundaries are considered outliers.",fig.align='center'}
library(cowplot)
library(tidyverse)
set.seed(3423)
y <- c(rnorm(110), 3.4)
s <- boxplot.stats(y)
df <- data.frame(y = c(s$stats, max(y)),
                 x = c(1.03, 1.405, 1.405, 1.405, 1.03, 1.04),
                 label = c("Minimum", "Lower quartile (25%tile)", "Median (50%tile)", 
                           "Upper quartile (75%tile)", "Maximum", 
                           "Outlier"))
p_boxplot <- ggplot(data.frame(y), aes(x = 1, y = y)) + 
  geom_boxplot(fill = "#15617b90", color = "#15617b",
               outlier.size = 3.2, outlier.color = "black", size = 1.5) +
  geom_text(data = df, aes(x, y, label = label), hjust = 0,
            size = 14/.pt, family = "serif") +
  annotate("text",x = 0.4, y = 0, label = "RIC",
             parse = TRUE,
             size = 14/.pt, family = "serif") +
  annotate("text",x = 0.85, y = 1.9, label = "whisker",
             parse = TRUE, fontface = "italic",
             size = 13/.pt, family = "serif") +
  annotate("text",x = 0.85, y = -1.75, label = "whisker",
             parse = TRUE, fontface = "italic",
             size = 13/.pt, family = "serif") +
  annotate("segment", x = 0.5, xend = 0.5, y = 0.8,
          yend = -0.8, arrow = arrow(ends = "both",
          angle = 90, length = unit(0.2, "cm")),
          color = "darkred", size = 1) +
  scale_x_continuous(limits = c(0, 2.2), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.8), expand = c(0, 0)) +
  labs(x= "", y = "") +
  theme_us_classic() + 
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_blank())

p_boxnotch <- ggplot(data.frame(y), aes(x = 0, y = y)) + 
  geom_boxplot(fill = "#15617b90", color = "#15617b",
               outlier.size = 3.2, outlier.color = "black", size = 1.5,
               notch = TRUE) +
  geom_text(data = df, aes(x, y, label = label), hjust = 0,
            size = 14/.pt, family = "serif") +
  annotate("text",x = -1, y = 0, label = "Notch",
             parse = TRUE,
             size = 14/.pt, family = "serif") +
  scale_x_continuous(limits = c(-1.8, .4), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.5), expand = c(0, 0)) +
  labs(x= "", y = "") +
  theme_us_classic() + 
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_blank())

plot_grid(p_boxnotch,p_boxplot,rel_widths = c(0.25, 1), nrow = 1)

```

The main components of this type of graph are described below: 

- **Minimum and maximum**: The smallest and largest value, respectively.

- **Median**: Also known as the 50th percentile (Q2 or m), represented by a line inside the box. 

- **Upper Quartile**: Also known as the 75th percentile (or Q3), and is represented as the upper edge of the rectangle (box).

- **Lower Quartile**: Also known as the 25th percentile (or Q1), and is represented as the bottom edge of the box.

- **Interquartile range**: Represents the height of your box and covers the central 50% of the data. It is the difference between Q3 and Q1.

- **Outliers**: These are individual data points that are farther away from the median than the edges of the whiskers.


This plot has certain limitations and you should be aware of them if you wish to use it in your research. 

- This type of plot is often unfamiliar to many people, and if you want to explain it to your audience, it is likely to take several minutes for them to understand. Therefore, an alternative chart should be considered if your target audience is unfamiliar with this plot [@amy20]. In my personal experience, when I first saw a box diagram, I found it difficult to understand, which led me to look for books and explanatory videos to better understand it. 

- It does not represent the distribution of data as accurately as a histogram or other distribution charts. In addition, it tends to give the impression that the distributions have a “bell shape”, as if the values are clustered around the median and gradually spread out from it [@Nick20].


Because of these limitations, some variations of the box plot have been developed to improve the visualization of the data distribution. In Figure \@ref(fig:boxplot0) (left), a notched box plot is presented, which facilitates the comparison of the differences between the medians of the samples. If the notches of two samples do not overlap, it is a clear indication that there are significant differences between them. A better option would be violin plots, which include all the components of box plots, but add information about the density of the data along the points by means of smoothed histograms. Finally, a strip plot would be another better option, as it shows you the distribution of your data by points.

(ref:boxplot1) Maternal anti-S IgG levels in patients with and without a history of SARS-CoV-2 infection. The following vaccination statuses were analyzed: unvaccinated (NoVx), partially vaccinated (PartVx), fully vaccinated (FullVx) and booster (BoostVx) in both groups. Data are represented by box plots (center line: median; box boundaries: first and third quartiles; whiskers: 1.5 times the interquartile range; black dot: media). 

Data points are shown as individual points and are represented by box plots (center line: median; box boundaries: first and third quartiles; whiskers: 1.5 times the interquartile range; black dot: media).

```{r boxplot1, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:boxplot1)', fig.align='center'}
library(readxl)
library(tidyverse)

enhances <- read_xlsx(path = 
        "data/Chapter06/enhances_vac.xlsx",
       col_names = TRUE, sheet = "Figure 1") %>%
       dplyr::select(c(3,5)) %>%
       dplyr::rename(Maternal = "Maternal IgG") %>%
       dplyr::mutate(Group2 = factor(Group,
                    levels = c(
                          "NoVx","NoVx Inf",
                          "PartVx","PartVx Inf",
                          "FullVx","FullVx Inf",
                          "BoostVx","BoostVx Inf")))
e <- ggplot(enhances, aes(x = Group2,
                         y = log2(Maternal)))
e + geom_hline(yintercept = c(1),
    color = "gray50", size = 0.6,linetype = 2) +
    geom_boxplot(aes(fill = Group2),
            alpha = 0.5, notch = TRUE, color ="gray50", 
            size = 1,outlier.shape = NA) +
    stat_summary(fun.y = "mean", geom = "point", 
                 shape = 20,size = 4, 
                 color = "black") +
    annotate("text",x = 2.4, y = 2, label = "Average: 1",
             parse = TRUE, color = "gray50", 
             size = 11/.pt) + 
    scale_y_continuous(limits=c(0, 10),
               breaks=seq(0, 10, by=2)) +
    scale_x_discrete(limits = rev) +
    scale_fill_manual(values = c("#E69F00",
                      "#56B4E9",
                      "#E69F00",
                      "#56B4E9",
                       "#E69F00",
                      "#56B4E9",
                      "#E69F00",
                      "#56B4E9")) + 
    labs(x = "",
         y = "Maternal IgG (log2)") +
    coord_flip() +
    theme_us_classic() +
    theme(legend.position = "none",
          plot.margin = margin(4, 4, 0.1, 0.1))
```

Here, we will notched box plots (Figure \@ref(fig:boxplot1)) showing the levels of protein S-binding antibodies measured in 4600 women and their newborns, according to different vaccination status and history of SARS-CoV-2 infection [@Murphy2023]. When loading our data, we will select the variables we will use and rename one of them. Subsequently, we will create a new variable, following the order presented in the article.

```{r, error=FALSE, message=FALSE, warning=FALSE}

library(readxl)

enhances <- read_xlsx(path = 
        "data/Chapter06/enhances_vac.xlsx",
       col_names = TRUE, sheet = "Figure 1") %>%
       dplyr::select(c(3,5)) %>%
       dplyr::rename(Maternal = "Maternal IgG") %>%
       dplyr::mutate(Group2 = factor(Group,
                    levels = c(
                          "NoVx","NoVx Inf",
                          "PartVx","PartVx Inf",
                          "FullVx","FullVx Inf",
                          "BoostVx","BoostVx Inf")))
head(enhances,4)
```


```{r, warning=FALSE, message=FALSE, error=FALSE}

e <- ggplot(enhances, aes(x = Group2,
                         y = log2(Maternal)))

```

Once our data is ready, we plot the notched box plots using the argument `notch = TRUE` in the `geom_boxplot()` function. \index{geom\_boxplot function} In addition, we added the *mean* (represented with a point) using the arguments `fun.y = “mean”` and `geom = “point”` in the `stat_summary()` function. \index{stat\_summary function}

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

e + geom_hline(yintercept = c(1),
    color = "gray50", size = 0.6,linetype = 2) +
    geom_boxplot(aes(fill = Group2),
            alpha = 0.5, notch = TRUE, color ="gray50", 
            size = 1,outlier.shape = NA) +
    stat_summary(fun.y = "mean", geom = "point", 
                 shape = 20,size = 4, 
                 color = "black") +
    annotate("text",x = 2.4, y = 2, label = "Average: 1",
             parse = TRUE, color = "gray50", 
             size = 11/.pt) + 
    scale_y_continuous(limits=c(0, 10),
               breaks=seq(0, 10, by=2)) +
    scale_x_discrete(limits = rev) +
    scale_fill_manual(values = c("#E69F00",
                      "#56B4E9",
                      "#E69F00",
                      "#56B4E9",
                       "#E69F00",
                      "#56B4E9",
                      "#E69F00",
                      "#56B4E9")) + 
    labs(x = "",
         y = "Maternal IgG (log2)") +
    coord_flip() +
    theme_us_classic() +
    theme(legend.position = "none")
```


Figure \@ref(fig:boxplot1) shows the anti-S IgG response to SARS-CoV-2 vaccination in relation to delivery. We studied 3589 patients with no history of SARS-CoV-2 infection and 1011 patients with a documented history of infection. Among the 3589 patients with no prior infection, each dose of vaccine caused a significant increase in IgG levels, especially after receiving a booster dose (BoostVx). However, in the 1011 patients with a history of SARS-CoV-2 infection, the first dose of vaccine already generated a significant increase in IgG levels. When comparing both groups, those with a history of infection showed significantly higher IgG levels in all vaccination cohorts. 

```{block2, box , type='rmdtip'}

__Want to know more?__

- The `glue()` function allows you to combine string text with R expressions to handle customizations in a more flexible way.

- The `stat_summary()` function in ggplot2 allows you to create visualizations that display summary metrics for specific variables in a data frame.

- We can modify our data in logarithmic scale, using the R function `log10()` or `log2()`. 

- With the `annotate()` function you can add text labels, areas and segments. 

```


## Violin plot {#violinplot}

Another distribution plot widely used by scientists is the violin plot. \index{Violin plot} It combines a box plot with a **kernel density** plot, which is rotated 90 degrees and mirrored. The width of the violin in this plot represents the density of the data: the wider the violin, the higher the density, and the narrower the violin, the lower the density. A key aspect to consider when creating this plot is kernel density estimation (KDE), which is a non-parametric way of estimating the probability density function (PDF) of a random variable. The KDE smooths the data points to provide a continuous representation of the data distribution.

(ref:violinplot0) Anatomy of a violin plot. Basic violin plot (left) and overlaid with a box plot (right). A violin plot is essentially a box plot with a probability density function (PDF) added on top. The PDF is essentially a smoothed histogram showing how often each value occurs.

```{r violinplot0, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:violinplot0)', fig.align='center'}
library(cowplot)
set.seed(3423)
y <- c(rnorm(120), 3.4)
s <- boxplot.stats(y)
df <- data.frame(y = c(s$stats, max(y)),
                 x = c(1.03, 1.405, 1.405, 1.405, 1.03, 1.04))
p_violin <- ggplot(data.frame(y), aes(x = 1, y = y)) + 
  geom_violin (fill = "#15617b", color = "#15617b",
               size = 1, alpha = 0.5) + 
  scale_x_continuous(limits = c(0, 2.2), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.8), expand = c(0, 0)) +
  labs(x= "", y = "",
       title= "Basic violin plot") +
  theme_us_classic() + 
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        plot.title = element_text(size = 16, hjust = 0.5))

p_vio_plot <- ggplot(data.frame(y), aes(x = 0, y = y)) + 
  geom_violin(fill = "#15617b", color = "#15617b",
              size = 1, alpha = 0.5) +
  geom_boxplot(fill = "white", width = 0.3) +
  stat_summary(fun.y = "mean", geom = "point",
      shape = 21, size = 2, fill = "black") +
  scale_x_continuous(limits = c(-1, 2.2), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.8), expand = c(0, 0)) +
  labs(x= "", y = "",
       title = "Violin plot overlaid box plot") +
  theme_us_classic() + 
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        plot.title = element_text(size = 16))

plot_grid(p_violin,p_vio_plot,rel_widths= c(0.25,0.25), nrow = 1)

```

Unlike box plots, this type of plot not only shows summary statistics, such as ranges and quartiles, but also represents the density of each variable. In addition, one of its advantages is that it can accurately represent bimodal or multimodal distributions, something a box plot cannot do. The main disadvantage is that they are less effective for small sample sizes, as the density estimation may be inaccurate.

Here we will use data from blood samples taken from males in four high-altitude locations (Ethiopia, the Andes, Tibet, and the United States), which compared hemoglobin concentration [@Beall2002]. 

(ref:violinplot1) Violin plot depicting hemoglobin concentration in men residing at high altitude in three regions of the world: the Andes, Ethiopia and Tibet. For reference, a fourth population of men living at sea level (USA) is added. The violin plots show kernel density trace or smoothed histograms to describe the distribution pattern of data and are overlaid with boxplots.

```{r violinplot1, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:violinplot1)', fig.align='center'}
library(tidyverse)
hemoglobin <- read.csv(
  file = "data/Chapter06/hemoglobin.csv", 
  header = TRUE
  )

h <- ggplot(hemoglobin,
           aes(x = population,
           y = hemoglobin))

h + geom_violin(fill = "#56B4E9D0", color = "#56B4E9",
                size = 1, alpha = 0.2, 
                adjust = 2) +
    geom_boxplot(width = 0.1, fill = "white", 
                 outlier.colour = NA) +
    stat_summary(fun.y = "mean", geom = "point",
      shape = 21, size = 2, fill = "black") +
    labs(x = "",
         y = "Hemoglobin concentration (gm/dl)") +
    theme_us_classic() + 
    theme(legend.position = "none",
          plot.margin = margin(7, 7, 3, 1.5))

```


```{r, error=FALSE, message=FALSE, warning=FALSE}

hemoglobin <- read.csv(
  file = "data/Chapter06/hemoglobin.csv", 
  header = TRUE
  )

head(hemoglobin,4)
```


```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

h <- ggplot(hemoglobin,
           aes(x = population,
           y = hemoglobin))

```

We used the `geom_violin()` function to create the violin plots, and then used `geom_boxplot()` to superimpose the box plots over the violins. The bandwidth was also adjusted with the argument `adjust = 2`. \index{geom\_violin function} Subsequently, the function `stat_summary()` was used to represent the mean of the data by a point.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(tidyverse)

h + geom_violin(fill = "#56B4E9D0", color = "#56B4E9",
                size = 1, alpha = 0.2, 
                adjust = 2) +
    geom_boxplot(width = 0.1, fill = "white", 
                 outlier.colour = NA) +
    stat_summary(fun.y = "mean", geom = "point",
      shape = 21, size = 2, fill = "black") +
    labs(x = "",
         y = "Hemoglobin concentration (gm/dl)") +
    theme_us_classic() + 
    theme(legend.position = "none")

```

It is clear from Figure \@ref(fig:violinplot1) that only men from the high Andes showed elevated hemoglobin concentrations, while men from the highlands of Ethiopia and Tibet had no significant difference in hemoglobin concentration compared to the sea level group (USA).

## Strip plot {#strip-plot}

A scatter plot on a single axis used to visualize the distribution of multiple one-dimensional values. \index{Strip plot} Values are plotted as points along that axis, and points with the same value may overlap. This plot allows one to observe whether the distributions are higher or lower, concentrated or sparse, normal or skewed, or have multimodal distributions. 

```{r stripplot0, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "Strip plot and its variations.",fig.align='center'}
library(cowplot)
library(ggbeeswarm)
library(tidyverse)
set.seed(3423)
y <- c(rnorm(250), 3)
s <- boxplot.stats(y)
df <- data.frame(y = c(s$stats, max(y)),
                 x = c(1.03, 1.405, 1.405, 1.405, 1.03, 1.04))
p_strip <- ggplot(data.frame(y), aes(x = 1, y = y)) + 
  geom_point(color = "#15617b", size = 2) +
  scale_x_continuous(limits = c(0, 2.2), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.8), expand = c(0, 0)) +
  labs(x= "", y = "",
    title = "Strip\nplot") +
  theme_us_classic() + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank())

p_jitter <- ggplot(data.frame(y), aes(x = 1, y = y)) + 
  geom_jitter(position=position_jitter(0.3),
              color = "#15617b", size = 2) +
  scale_x_continuous(limits = c(0, 2.2), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.8), expand = c(0, 0)) +
  labs(x= "", y = "",
       title = "Jitter\nplot") +
  theme_us_classic() + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank())

p_swarm <- ggplot(data.frame(y), aes(x = 1, y = y)) + 
  geom_beeswarm(color = "#15617b",
                method = "swarm",
                cex    = 3,
                size= 1.5) +
  scale_x_continuous(limits = c(0, 2.2), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.8), expand = c(0, 0)) +
  labs(x= "", y = "",
       title = "Beeswarm\nplot") +
  theme_us_classic() + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank())


plot_grid(p_strip,p_jitter,p_swarm,rel_widths = c(0.25, 0.25), nrow = 1)

```

The problem with a **strip plot** is that there can be a very dense clustering of data points, causing them to overlap. To avoid this, the individual values must be adjusted slightly, using a version called a **jitter plot**. Although this variant improves the visualization, there can still be overlapping points. To resolve this, the **beeswarm plot** is more effective, as it adjusts the points to the minimum distance necessary to avoid overlapping (Figure \@ref(fig:stripplot0)).

We will use a data set from a study that seeks to determine whether the “sex peptide” (SP) ejaculated by *Drosophila melanogaster* males reduces the life expectancy of females after mating [@Barnes2008].

```{r stripplot1, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= "Jitter plot showing the lifespan of fertile and sterile females exposed to high and low cost mating regimes. Data show fertile (blue dots) and sterile (red dots) females. The lines connect the average lifespan between the two treatments: fertile females are represented by a solid line, while sterile females are indicated by a dashed line.",fig.align='center'}

library(ggbeeswarm)
library(tidyverse)

life_span <- read.csv(
  file = "data/Chapter06/LifeSpan.csv", 
  header = TRUE
  )
s = ggplot(life_span, aes(x = treatment   ,
                         y = lifespanDays,
                         color = fertility))
s + geom_point(position=position_jitterdodge(
                      jitter.width = 0.13,
                      dodge.width = 0.3),
               size = 2.5, alpha= 0.4) +
    labs(y = "Life Span (days)", x = "Treatment") +
    scale_color_manual(values = c("dodgerblue3",
                        "firebrick3")) +
    stat_summary(aes(group = fertility, y =lifespanDays,
                     linetype = fertility), 
                 fun.y = mean, geom = "line", 
                 color= "black", size = 1,
                 position = position_dodge(0.3),
                 show.legend = FALSE) +
    stat_summary(aes(group = fertility, y =lifespanDays), 
                 fun.y = mean, geom = "point",
                 color = "black", size = 3,
                 position = position_dodge(0.3)) +
    scale_x_discrete(limits =c("low-cost", 
                               "high-cost")) +
    theme_us_classic() +
    theme(legend.title = element_blank(),
          legend.key = element_blank(),
          plot.margin = margin(4, 4, 0.1, 0.1))


```


```{r, error=FALSE, message=FALSE, warning=FALSE}

life_span <- read.csv(
  file = "data/Chapter06/LifeSpan.csv", 
  header = TRUE
  )
head(life_span,4)
```


```{r, warning=FALSE, message=FALSE, error=FALSE}

s <- ggplot(life_span, aes(x = treatment   ,
                         y = lifespanDays,
                         color = fertility))

```

After loading the data, we plotted the strip plots using the `geom_point()` function, and jitter was applied to the points with the argument `position = position_jitterdodge()`. In this argument, one can adjust the degree of jitter in the x-direction with `jitter.width` and the amount of displacement in the x-direction with `dodge.width`. In addition, transparency was added to the points using the argument `alpha = 0.4`. The transparency of the points was used to highlight the mean (black point) of both groups using the function `stat_summary()` with the arguments `fun.y = mean` and `geom = “point”`. In addition, the means were connected by lines using the same `stat_summary()` function with arguments `fun.y = mean` and `geom = “line”`. Both the average and the lines connecting them must have the same value of the amount to dodge in the x-direction (position_dodge(0.3)).

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

s + geom_point(position=position_jitterdodge(
                      jitter.width = 0.13,
                      dodge.width = 0.3),
               size = 2.5, alpha= 0.4) +
    labs(y = "Life Span (days)", x = "Treatment") +
    scale_color_manual(values = c("dodgerblue3",
                        "firebrick3")) +
    stat_summary(aes(group = fertility, y =lifespanDays,
                     linetype = fertility), 
                 fun.y = mean, geom = "line", 
                 color= "black", size = 1,
                 position = position_dodge(0.3),
                 show.legend = FALSE) +
    stat_summary(aes(group = fertility, y =lifespanDays), 
                 fun.y = mean, geom = "point",
                 color = "black", size = 3,
                 position = position_dodge(0.3)) +
    scale_x_discrete(limits =c("low-cost", 
                               "high-cost")) +
    theme_us_classic() +
    theme(legend.title = element_blank(),
          legend.key = element_blank())

```

The scientists kept young female flies with fertile young males, either intermittently (low-cost treatment) or continuously (high-cost treatment), for the rest of their lives, up to 56 days. The results Figure \@ref(fig:stripplot1), showed that the low-cost mating groups lived significantly longer than the high-cost mating groups in both the control group (fertile females) and the sterile females (*ovoD1*).

```{block2, strip , type='rmdtip'}

__Want to know more?__

- To make the bee swarm plot, you can use the **ggbeeswarm** package, which is an extension of the ggplot package. 
- The `geom_jitter` function is a shortcut of the `geom_point(position = “jitter”)` function.

```

## In conclusion {#conclusion}

Bar charts and their variants are widely used due to their ease of reading. However, it is essential to consider their limitations, such as the fact that they only present a summary statistic, like the mean, which implies the loss of valuable information. In addition, they can be misleading because they represent very small data. To obtain a more complete view of the distribution of data and to facilitate comparisons between groups, box plots, violin plots and strip charts are more suitable options.

We also discussed pie charts, which, although popular, are often criticized by the data science community. However, some recommendations for their use were shown, such as avoiding pie charts with too many sections, as they make them difficult to interpret.

## To practice!

### Exercise 1

Uses a data set on a study of a genus of male spiders (*Tidarren*). Males amputate one of their pedipalps (copulatory organ) before sexual maturation, and this event causes them to improve their locomotor performance and endurance [@ramos1].

What you are going to do is to plot a box plot, plus add the mean. 

```{r, error=FALSE, message=FALSE, warning=FALSE}

spider <- read.csv(
  file = "data/Chapter06/spider_amputation.csv", 
  header = TRUE
  )
```


### Exercise 2

We will use a data set on the beak size of three subspecies of finch birds [@Schluter1988]. Make a fiddle plot and add distribution points with the `geom_jitter` function, and see which subspecies has the largest size. 
 

```{r, error=FALSE, message=FALSE, warning=FALSE}

finches <- read.csv(
  file = "data/Chapter06/kenya_finches.csv", 
  header = TRUE
  )
```

