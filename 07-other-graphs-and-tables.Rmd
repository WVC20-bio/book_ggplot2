# Other plots and tables {#other-plots}

In previous chapters, we explored how to create various types of graphs using mainly ggplot2. However, many graphs cannot be generated directly with this tool. For this reason, ggplot2 extensions have been developed to facilitate the creation of specific graphs. Another way to present data is through tables, which are especially useful for showing the exact values of each data point. In this chapter, we will focus on creating other types of graphs using ggplot2 extensions and designing tables using R.

## Mosaic plot {#mosaic-plot}

The mosaic plot resembles a stacked bar chart, but with the difference that in the mosaic plot both the heights and widths of the shaded areas vary. \index{Mosaic plot} Within each stack, the area and height of the bars represent the relative frequencies, i.e., the proportions of the responses. This visualization is useful for showing relationships between categorical variables and provides a visual way to compare groups. In biology, it is recommended for representing frequency data in case-control studies.

(ref:mosaicplot) Mosaic plot showing the relative frequency of *Toxoplasma gondii* infection in a sample of drivers involved in traffic accidents (study group) compared to a sample of drivers with no accident history (control group).

```{r mosaicplot, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:mosaicplot)',fig.align='center'}
library(ggmosaic)
accidents <- read.csv(
  file = "data/Chapter07/toxoplasma_accidents.csv", 
  header = TRUE
  )

p0 <- ggplot(accidents) +
      geom_mosaic(aes(x = product(condition),
          fill=accident),
          show.legend = FALSE) 

p1 <- p0 + geom_text(
           data = ggplot_build(p0)$data[[1]], 
            aes(x = (xmin+xmax)/2, 
            y = (ymin+ymax)/2, label=.wt),
           color = "white",
           size = 12/.pt) +
  scale_fill_manual(values = c("#da6051", 
                    "#15617b"), 
                    guide = "none") +
  theme_us_classic() +
  theme(axis.ticks = element_blank(),
    axis.line = element_blank(),
    axis.title = element_blank(),
    axis.ticks.length = unit(0, "pt"),
    panel.spacing.x = unit(0, "pt"),
    plot.margin = margin(14, 7, 3, 1.5))
p1

```

Next, we will use a data set where they investigated (Figure \@ref(fig:mosaicplot)) the incidence of *Toxoplasma gondii* among the population that was involved in a traffic accident while driving [@Yereli2006]. The authors compared the prevalence of *Toxoplasma gondii* between a sample of 185 drivers aged 21-40 years who had been involved in a traffic accident (study group) and another sample of 185 drivers with similar age and sex characteristics, but with no accident history (control group).The main limitation of this plot is the difficulty in comparing lengths or heights when they are not aligned on the same baseline.

```{r, error=FALSE, message=FALSE, warning=FALSE}

accidents <- read.csv(
  file = "data/Chapter07/toxoplasma_accidents.csv", 
  header = TRUE
  )

head(accidents,4)

```

After entering our data, a contingency table showing the frequency of the data was prepared.

```{r, error=FALSE, message=FALSE, warning=FALSE}

tox_t <- table(accidents$accident, 
               accidents$condition)

head(tox_t)

```

To create our graph we use the **ggmosaic** package and the `geom_mosaic()` function. \index{geom\_mosaic, ggmosaic} Then, we added labels to the data values with geom_text(). Finally, we made some adjustments to the axes to correctly place the labels corresponding to the treatment group. 

Figure \@ref(fig:mosaicplot) shows the association between two variables, with *Toxoplasma* infection as the explanatory variable and the occurrence of an accident as the response variable.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(ggmosaic)

p0 <- ggplot(accidents) +
      geom_mosaic(aes(x = product(condition),
          fill=accident),
          show.legend = FALSE) 

p1 <- p0 + geom_text(
           data = ggplot_build(p0)$data[[1]], 
            aes(x = (xmin+xmax)/2, 
            y = (ymin+ymax)/2, label=.wt),
           color = "white",
           size = 14/.pt) +
  scale_fill_manual(values = c("#da6051", 
                    "#15617b"), 
                    guide = "none") +
  theme_us_classic() +
  theme(axis.ticks = element_blank(),
    axis.line = element_blank(),
    axis.title = element_blank(),
    axis.ticks.length = unit(0, "pt"),
    panel.spacing.x = unit(0, "pt"))
p1

```


## Parallel coordinates plot {#parallel-plot}

Parallel coordinate plots are ideal for comparing multiple variables and analyzing their relationships. In this type of graph, each variable is plotted on an axis parallel to the others. The data values are plotted on the vertical axes and connected by lines. The axes can have different scales, since each variable can be in a different unit of measurement, or they can be normalized to make the scales uniform, which makes it easier to observe multiple correlations in a single visualization. This visualization has been used in the analysis of complex and dynamic biochemical networks of certain diseases, the generation of hypotheses in the characterization of tumor tissue, but in areas of health sciences, it is very limited [@Mitku2020].

(ref:parallelplot) Parallel coordinate plot with axes scaled to the same range.

```{r parallelplot, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:parallelplot)',fig.align='center'}

library(GGally)

  ggparcoord(data = iris,
        columns = 1:4,
        groupColumn = "Species",
        scale = "globalminmax") +
        scale_color_manual(values = c(
            "#059e73", "#eba432","#1876ba")) +
  scale_y_continuous(breaks = c(0,8),
                     expand = c(0,0)) +
  annotate("text",x = 4.28, y = 2.1, 
          label = "Virginica",
          parse = TRUE,size = 13/.pt, 
           family = "serif",
          color = "#1876ba") +
  annotate("text",x = 4.32, y = 1.3, 
          label = "Versicolor",
          parse = TRUE,size = 13/.pt, 
          family = "serif",
          color = "#eba432") +
  annotate("text",x = 4.2, y = 0.3, 
          label = "Setosa",
          parse = TRUE,size = 13/.pt, 
          family = "serif",
          color = "#059e73") +
  geom_vline(
    xintercept= 1,
      linetype= "solid", colour="gray50") +
  geom_vline(
    xintercept= 2,
      linetype= "solid", colour="gray50") +
  geom_vline(
    xintercept= 3,
      linetype= "solid", colour="gray50") +
  geom_vline(
    xintercept= 4,
      linetype= "solid", colour="gray50") +
  geom_hline(yintercept = 0, color = "gray50",
              linetype= "dashed") +
  geom_hline(yintercept = 8, color = "gray50",
              linetype= "dashed") +
  labs(y = "", x = "") +
  coord_cartesian(clip = "off") +
  theme_us_classic() +
  theme(axis.line.x.bottom = element_blank(),
        axis.line.y.left = element_blank(),
        axis.ticks= element_blank(),
        legend.position = "none",
        plot.margin = margin(14, 7, 3, 1.5))

```

When creating this type of chart, it is important to consider the order of the axes, since strategically rearranging them may reveal patterns or correlations between variables. It is also advisable to properly adjust the height of the axes and the distance between them. In addition, when working with large data sets, the chart can become confusing; in these cases, a good color strategy can be very useful to improve visualization.

We will use the data called flowers [@iris2], which contains analysis of measurements (e.g. petal size) of three species of plants of the genus *Iris* (setosa, versicolor, virginica). Figure \@ref(fig:parallelplot) was created using the `ggparcoord()` function of the **GGally** package. \index{ggparcoord, GGally} The number of columns for numeric variables is defined with the columns argument. The categorical variable Species was used to assign colors to the rows, using the argument `groupColumn`. Then, the argument `scale="globalminmax”` was applied to unify the scales of the variables and, with the function `scale_y_continuous()`, a uniform scale was established for all of them. 

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(GGally)

   ggparcoord(data = iris,
        columns = 1:4,
        groupColumn = "Species",
        scale = "globalminmax") +
        scale_color_manual(values = c(
            "#059e73", "#eba432","#1876ba")) +
  scale_y_continuous(breaks = c(0,8),
                     expand = c(0,0)) +
  annotate("text",x = 4.28, y = 2.1, 
          label = "Virginica",
          parse = TRUE,size = 13/.pt, 
           family = "serif",
          color = "#1876ba") +
  annotate("text",x = 4.32, y = 1.3, 
          label = "Versicolor",
          parse = TRUE,size = 13/.pt, 
          family = "serif",
          color = "#eba432") +
  annotate("text",x = 4.2, y = 0.3, 
          label = "Setosa",
          parse = TRUE,size = 13/.pt, 
          family = "serif",
          color = "#059e73") +
  geom_vline(
    xintercept= 1,
      linetype= "solid", colour="gray50") +
  geom_vline(
    xintercept= 2,
      linetype= "solid", colour="gray50") +
  geom_vline(
    xintercept= 3,
      linetype= "solid", colour="gray50") +
  geom_vline(
    xintercept= 4,
      linetype= "solid", colour="gray50") +
  geom_hline(yintercept = 0, color = "gray50",
              linetype= "dashed") +
  geom_hline(yintercept = 8, color = "gray50",
              linetype= "dashed") +
  labs(y = "", x = "") +
  coord_cartesian(clip = "off") +
  theme_us_classic() +
  theme(axis.line.x.bottom = element_blank(),
        axis.line.y.left = element_blank(),
        axis.ticks= element_blank(),
        legend.position = "none")


```

## Ridgeline plot {#ridgeline-plot}

The ridgeline plot consists of a series of histograms or density plots superimposed on the y-axis, allowing the distribution between different groups to be visualized and compared in a general way. \index{Ridgeline plot} These plots are especially useful for showing trends in distributions over time. When making this type of graph, it is important to consider both the order of the groups and the number of groups represented, avoiding making them too small.

(ref:ridgelineplot) Ridgeline plot illustrate the temporal variation of bottom temperature at Mohawk Reef (Santa Barbara, CA). A vertical line has been added to indicate the average temperature (14.5 °C). Temperatures (°C) aggregated by month from 2005 - 2022. Data source: EDI Data Portal. Note: Graph based on the publication by @sandra22. 

```{r ridgelineplot, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:ridgelineplot)',fig.align='center'}

library(chron)
library(naniar)
library(ggridges)

mko <- read.csv(
  file = "data/Chapter07/mohawk_mooring_mko_20240801.csv", 
  header = TRUE
  )

mko2 <- mko %>%
       select(year, month, day, decimal_time, 
              Temp_bot, Temp_top, Temp_mid) %>%
       unite(date, year, month, day, sep = "-", 
             remove = FALSE) %>% 
       mutate(time = chron::times(as.numeric(
              decimal_time))
              ) %>% 
       unite(date_time, date, time, sep = " ") %>% 
       mutate(date_time = as.POSIXct(date_time, 
              "%Y-%m-%d %H:%M:%S", tz = "GMT"),
       year = as.factor(year),
       month = as.factor(month),
       day = as.numeric(day),
       Temp_top = as.numeric(Temp_top), 
       Temp_mid = as.numeric(Temp_mid), 
       Temp_bot = as.numeric(Temp_bot)) %>%
       mutate(month_name = as.factor(
               month.name[month])) %>%
       replace_with_na(replace = list(Temp_bot = 9999, 
                Temp_top = 9999, 
                Temp_mid = 9999)) %>%
       select(date_time, year, month, day, month_name, 
              Temp_bot, Temp_mid, Temp_top) 

average = mko2 %>%
          summarize(mean_temp = round(mean(Temp_bot, 
                na.rm = TRUE), 1)) %>%
          pull()

mkp =  mko2 %>%
  group_by(month_name)%>%
  ggplot(aes(x = Temp_bot, y = month_name, 
            fill = after_stat(x))) +
  geom_density_ridges_gradient(
            rel_min_height = 0.01, 
            scale = 3) +
  scale_x_continuous(breaks = c(9, 12, 15, 
            18, 21),
            labels = c("9°C", "12°C", "15°C",
            "18°C", "21°C"),
            name= NULL) +
  scale_y_discrete(limits = rev(month.name),
            name = NULL) +
  geom_vline(xintercept = average, linetype = "dashed", 
             color = "black") +
  annotate(geom = "segment", x = 18, y = "April", 
           xend = average, yend = "May",
           arrow = arrow(length = unit(3, "mm"))) +  
  annotate(geom = "text", x = 18, y = "April", 
           label = paste0(" Avg Temp = ", average, "°C"), 
           hjust = "left") + 
  scale_fill_gradientn(colours = c("#d01c8b", "#f1b6da", "#f7f7f7",
            "#b8e186", "#4dac26"),
    name = "Temp. (°C)",
    guide = guide_colorbar(
    ticks = FALSE)) +
  theme_us_classic() +
  theme(axis.line= element_blank(),
        axis.ticks.y.left = element_blank(),
        plot.margin = margin(14, 7, 3, 1.5))
  
mkp


```

Figure \@ref(fig:ridgelineplot) shows the temporal variation of bottom temperature at Mohawk Reef (Santa Barbara, CA), obtained from the [EDI](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-sbc&identifier=2007) data portal [@Washburn2]. When downloading the raw dataset, it contains many variables (87) and several observations from 2005 to 2022. Therefore, we must perform the cleaning of our data and select the variables of interest. The cleaning of the data, we took into account the script published by [Samantha Csik](https://github.com/UCSB-MEDS/ggplot2-workflow/blob/main/data-cleaning/ocean-temps-cleaning.R).

```{r, error=FALSE, message=FALSE, warning=FALSE}

library(chron)
library(naniar)

# Raw data
mko <- read.csv(
  file = "data/Chapter07/mohawk_mooring_mko_20240801.csv", 
  header = TRUE
  )

# Data cleansing

mko2 <- mko %>%
       select(year, month, day, decimal_time, 
              Temp_bot, Temp_top, Temp_mid) %>%
       unite(date, year, month, day, sep = "-", 
             remove = FALSE) %>% 
       mutate(time = chron::times(as.numeric(
              decimal_time))
              ) %>% 
       unite(date_time, date, time, sep = " ") %>% 
       mutate(date_time = as.POSIXct(date_time, 
              "%Y-%m-%d %H:%M:%S", tz = "GMT"),
       year = as.factor(year),
       month = as.factor(month),
       day = as.numeric(day),
       Temp_top = as.numeric(Temp_top), 
       Temp_mid = as.numeric(Temp_mid), 
       Temp_bot = as.numeric(Temp_bot)) %>%
       mutate(month_name = as.factor(
               month.name[month])) %>%
       replace_with_na(replace = list(Temp_bot = 9999, 
                Temp_top = 9999, 
                Temp_mid = 9999)) %>%
       select(date_time, year, month, day, month_name, 
              Temp_bot, Temp_mid, Temp_top) 

head(mko2[, 1:6],4)

```

This ridgeline plot was generated using the `geom_density_ridges_gradient()` function of the ggridges package, which organizes several density plots in a gradient fashion. To adjust the overlap between the different density plots, the `scale` argument was used. In addition, the `rel_min_height` argument was used to cut the tails of the densities, with a value of 0.01, which in this case proved to be very effective. Next, a line was added with `geom_vline()` to indicate the average temperature of the data. \index{geom\_vline function} Finally, the divergent color scale called “**PiYG**” was used, it is suitable for all forms of color vision deficiency. If you want to know more about the types of color scales have a look at Chapter \@ref(color).

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(ggridges)

average <- mko2 %>%
          summarize(mean_temp = round(mean(Temp_bot, 
                na.rm = TRUE), 1)) %>%
          pull()

mkp <- mko2 %>%
  group_by(month_name)%>%
  ggplot(aes(x = Temp_bot, y = month_name, 
            fill = after_stat(x))) +
  geom_density_ridges_gradient(
            rel_min_height = 0.01, 
            scale = 3) +
  scale_x_continuous(breaks = c(9, 12, 15, 
            18, 21),
            name= NULL) +
  scale_y_discrete(limits = rev(month.name),
            name = NULL) +
  geom_vline(xintercept = average, linetype = "dashed", 
             color = "black") +
  scale_fill_viridis_c(name = "Temp. [°C]", 
            option = "H") +
  theme_us_classic() +
  theme(axis.line= element_blank(),
        axis.ticks.y.left = element_blank())
  
mkp

```


```{block2, other1 , type='rmdtip'}

__Want to know more?__

In ridgeline plots, if you prefer to display histograms instead of density plots, you can use the argument `stat = “binline”`. Note, however, that overlapping histograms may look unusual, so it is advisable to use this option with a scale parameter less than 1.

```


## Kaplan-Meier Curve {#kmc-plot}

In biology, there are numerous studies devoted to survival analysis, a technique used to evaluate data related to the time to the occurrence of a specific event. This event may include examples such as relapse or non-relapse, onset or non-occurrence of dementia, reproduction or non-reproduction, and mortality or survival. It is important to consider factors that could influence the results; for example, a new group of samples should not be included in the middle of the study after treatment “X” has been applied [@Andrade2].

(ref:survivalc) Kaplan–Meier survival curve for time until settling of isopods in successful (black color line, *N = 32*) and unsuccessful (orange color line, *N = 84*) burrows. The median time to event is the time corresponding to a 0.50 proportion unsettled.

```{r survivalc, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:survivalc)',fig.align='center'}
library(survival)
library(survminer)

isopods <- read.csv(
  file = "data/Chapter07/desert_Isopods.csv", 
  header = TRUE
  )
isopods_KM <- survfit(Surv(days,
outcome) ~ burrow,
data = isopods, 
type = "kaplan-meier")

ggsurvplot(fit = isopods_KM, data = isopods,
   conf.int = TRUE,
   surv.median.line = "hv",
   palette = c("#eba432", "#0a0b0d"), 
   size = 1,
   xlab = "Days", 
   ylab = "Proportion unsettled",
   legend.title = "Burrow succes",
   legend.labs = c("Failed", "Successful"))  +
   theme_survminer(font.x = c(14),
   font.y = c(14), 
   font.tickslab = c(14,"black"), 
   font.legend = c(14, "black"),
   legend = c(0.80, 0.80))

```

In this analysis, the key variable is the time until the event occurs. There are two possible outcomes: that the event happens or does not happen (“*censored*”). Participants are considered “*censored*” if, during the study, they withdraw or do not experience the event or death before it ends. Thus, the advantage of this analysis is that it does not require all study subjects to have undergone the event by the time the research ends [@Andrade2].

The Kaplan-Meier curve illustrates the probability of survival (absence of the event or censored data) as a function of time. In this graph, the x-axis represents time, while the y-axis shows the probability of survival. The curve starts with 100% survival and descends in steps each time an individual in the sample experiences the event throughout the study [@Andrade2;@Goel2010].

For this example we used a survival analysis data set to investigate correlates of burrowing success in desert isopods (*Hemilepistus reaumuri*).

```{r, error=FALSE, message=FALSE, warning=FALSE}

isopods <- read.csv(
  file = "data/Chapter07/desert_Isopods.csv", 
  header = TRUE
  )

head(isopods,4)

```

Before plotting our Kaplan-Meier survival curve, we first performed the survival estimation with the `survfit()` function of the **survival** package. \index{survfit, survival}

```{r, error=FALSE, message=FALSE, warning=FALSE}

library(survival)

isopods_KM <- survfit(Surv(days,
outcome) ~ burrow,
data = isopods, 
type = "kaplan-meier")
isopods_KM

```

Then, we plot the survival curve (Figure \@ref(fig:survivalc)). The main function for this analysis is `ggsurvplot()` from the **survminer** package. \index{ggsurvplot, survminer} To optimize the display of the plot, we apply the `theme_survminer()` function. The `surv.median.line = “hv” `argument was used to show the estimated median survival time for the sampled populations. Finally, with the argument `conf.int = TRUE` provides 95% confidence limits for the median time to event in the populations.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(survminer)

ggsurvplot(fit = isopods_KM, data = isopods,
   conf.int = TRUE,
   surv.median.line = "hv",
   palette = c("#eba432", "#0a0b0d"), 
   size = 1,
   xlab = "Days", 
   ylab = "Proportion unsettled",
   legend.title = "Burrow succes",
   legend.labs = c("Failed", "Successful"))  +
   theme_survminer(font.x = c(14),
   font.y = c(14), 
   font.tickslab = c(14,"black"), 
   font.legend = c(14, "black"),
   legend = c(0.80, 0.80))

```

## Forest plot {#forest-plot}

It is rare for a single study to definitively confirm a new finding; in general, findings emerge from multiple, reproducible experiments. \index{Forest plot} The way to synthesize these studies to answer a specific question is through systematic reviews. These reviews compile studies on the prevalence of a clinical condition, prognostic factors, results of randomized trials, among others. In addition, they may include a meta-analysis, a statistical method that combines numerical data from individual studies into an overall estimate, commonly represented in a graph known as a forest plot [@Chang2022;@verhagen20].

(ref:forest) Forest plot showing first-time diagnosis of Alzheimer's disease among semaglutide matched by propensity score versus other antidiabetic drug groups in patients with type 2 diabetes mellitus. 

```{r forest, out.width = "0.8\\linewidth", fig.width = 13, fig.asp = 0.42, dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:forest)',fig.align='center'}
library(forestplot)

st <- read.csv(
  file = "data/Chapter07/semaglutide.csv", 
  header = TRUE,
  sep=","
  )

tabletext <- cbind(
            c("Size/Group",st$casecount),
            c("Exposure Group",st$controlcount),
            c("Comparison Group", st$blah),
            c("Exposure Group \nCases (Overall Risk)\n",
            st$case_group),
            c("Comparison Group \nCases(Overall Risk)\n", 
            st$control_group),
            c("HR (95% CI)",st$CI))


forestplot(labeltext=tabletext, 
           graphwidth = unit(90, 'mm'),
           graph.pos=6,
           is.summary=c(TRUE,rep(FALSE,12)),
           align = c("l", "l", "l"),
           mean=c(NA,st$AOR), 
           lower=c(NA,st$down),
           upper=c(NA,st$up),
           xlab="Hazard Ratio (HR)",
           hrzl_lines=list("2" = gpar(lwd = 1.2, 
            lty=1, col='black')),
           txt_gp=fpTxtGp(label=list(gpar(cex=0.9),
            gpar(cex=0.9),gpar(cex=0.9),gpar(cex=0.9),
            gpar(cex=0.9),gpar(cex=0.9)),
            ticks=gpar(cex=0.9),
            xlab=gpar(cex=0.9,col='black',
          fontface='bold')),
          clip=c(0.001, 2), 
          col=fpColors(box="black", lines="black", 
                zero = "black"),
          lwd.zero = 001,
          lwd.xaxis = 0.7,
          mar = unit(c(0,0,0,0), "mm"),
          zero=1, cex=0.01, lineheight = unit(6, "mm"), 
          boxsize=0.2, colgap=unit(6,"mm"),
          lwd.ci=0.8, ci.vertices=TRUE, 
          ci.vertices.height = 0.15)

```


Forest plots are a graphical representation showing the observed effect, confidence interval and weight of each study. In addition, they present the pooled effect obtained in a meta-analysis, which allows visualization of both the overall effect estimates and the heterogeneity between studies.

The forest plot shown in Figure \@ref(fig:forest) was created from data from a systematic review that included seven target emulation trials involving nearly 1.1 million patients with type 2 diabetes mellitus without a prior diagnosis of Alzheimer's disease. In these trials, semaglutide was compared with seven other antidiabetic drugs [@Wang2024]. The first column (on the left) shows the number of patients included in the seven trials. Then, columns 2 and 3 present the experimental group (patients who received semaglutide) and the control group (patients treated with other antidiabetics), respectively. Columns 4 and 5 indicate the total risk in the experimental and control groups. Columns 6 and 7 represent the outcome effect measure both graphically and numerically. In the graphical representation, the squares show the hazard ratio (HR), and the horizontal bars extend from the lower to the upper limit of the 95% confidence interval (95% CI) of this estimate. The size of each square is proportional to the weight of that study in the overall estimate. Finally, a vertical line, the “null effect line” (value 1), is included; if the square of a study does not cross this line, it indicates a statistically significant effect favoring the experimental group.

Patients with type 2 diabetes who were prescribed semaglutide had a significantly lower risk of being diagnosed for the first time with Alzheimer's disease during a 3-year follow-up compared with those treated with other antidiabetic drugs, such as insulin (HR = 0.33) and other GLP-1RAs (HR = 0.59).

```{r, error=FALSE, message=FALSE, warning=FALSE}

st <- read.csv(
  file = "data/Chapter07/semaglutide.csv", 
  header = TRUE,
  sep=","
  )

head(st,4)

```

After entering our data, we create a variable called *tabletext*. 

```{r, error=FALSE, message=FALSE, warning=FALSE}

tabletext <- cbind(
            c("Size/Group",st$casecount),
            c("Exposure Group",st$controlcount),
            c("Comparison Group", st$blah),
            c("Exposure Group \nCases (Overall Risk)\n",
            st$case_group),
            c("Comparison Group \nCases(Overall Risk)\n", 
            st$control_group),
            c("HR (95% CI)",st$CI))

```

The `forestplot()` function from the [forestplot](https://github.com/gforge/forestplot) package, was chosen to make our graph in Figure \@ref(fig:forest). It has many additional arguments to improve the appearance of our graph. 
Below we look at the final code:

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(forestplot)

pdf(file = "forestplot.pdf", width = 14, height = 6)

forestplot(labeltext=tabletext, 
           graphwidth = unit(90, 'mm'),
           graph.pos=6,
           is.summary=c(TRUE,rep(FALSE,12)),
           align = c("l", "l", "l"),
           mean=c(NA,st$AOR), 
           lower=c(NA,st$down),
           upper=c(NA,st$up),
           xlab="Hazard Ratio (HR)",
           hrzl_lines=list("2" = gpar(lwd = 1.2, 
            lty=1, col='black')),
           txt_gp=fpTxtGp(label=list(gpar(cex=0.9),
            gpar(cex=0.9),gpar(cex=0.9),gpar(cex=0.9),
            gpar(cex=0.9),gpar(cex=0.9)),
            ticks=gpar(cex=0.9),
            xlab=gpar(cex=0.9,col='black',
          fontface='bold')),
          clip=c(0.001, 2), 
          col=fpColors(box="black", lines="black", 
                zero = "black"),
          lwd.zero = 001,
          lwd.xaxis = 0.7,
          mar = unit(c(0,0,0,0), "mm"),
          zero=1, cex=0.01, lineheight = unit(6, "mm"), 
          boxsize=0.2, colgap=unit(6,"mm"),
          lwd.ci=0.8, ci.vertices=TRUE, 
          ci.vertices.height = 0.15)

dev.off()

```

Forest plots generated by `forestplot::forestplot` can be saved as a PDF or PNG file. To do this, you must first run the `pdf` or `png` or `svg` functions depending on the format you want to save your figure and then specify the width and height. Finally in the last line of your code, we have to include `dev.off()`, which will allow us to save the generated output in the file we specified above.

```{block2, other5 , type='rmdtip'}

__Want to know more?__

- You can also generate forest plots with the **metafor** and **ggforestplot** packages.

- The freely accessible web server called **SRplot** allows you to create a variety of plots by pasting your data, including a forest diagram. In the following link the web page: https://www.bioinformatics.com.cn/srplot.

- If you have ever seen the **Cochrane** Collaboration logo, it features a forest diagram illustrating a the potential of systematic reviews to improve health care. Visit their page here: https://www.cochrane.org/about-us/difference-we-make.

```

## Phylogenetic trees {#phylogenetic-plot}

Phylogenetic trees are used to represent and analyze the parentage and evolution of organisms from their genetic sequences. \index{Phylogenetic trees} These diagrams can be constructed using distance-based methods (such as UPGMA and neighbor-joining ) or character-based methods (such as maximum likelihood and Bayesian Markov Chain Monte Carlo). The maximum likelihood and Bayesian Markov Chain Monte Carlo methods are frequently used in scientific publications.

(ref:tree) Components of a rooted phylogenetic tree. The root of a phylogenetic tree indicates that an ancestral lineage originated all the organisms represented in the tree. This root (circled in red) represents the common ancestor of all the species included. The branches (horizontal lines) show evolutionary relationships, while the gray numbers indicate evolutionary changes. The nodes in blue circles mark the branch points where the lineages diverged, and the nodes in green circles correspond to real organisms that have been sampled and sequenced. Reference: Chart taken from @Yu2.  

```{r tree, message=FALSE, echo=F, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6, fig.cap='(ref:tree)', fig.align='center'}
library(ggtree)

set.seed(2017-04-22)
tr <- rtree(10)
p <- ggtree(tr) + 
  geom_nodepoint(color='#eba432', size=3) + 
  geom_rootpoint(size=3, color='#da6051') + 
  geom_tippoint(color='#059e73', size=3) +
  geom_text2(aes(subset=(node != parent), 
                 label=round(branch.length, 2), 
              x=branch), 
             vjust=-.5, color='grey50', size=3) + 
  geom_treescale() 

d <- p$data
i <- d$isTip
d$label[i][order(d$y[i],decreasing=F)] <- paste0('virus', 10:1)
p$data <- d
p + geom_tiplab(offset = .05, size=4.5) + xlim(NA,4)

```

A rooted phylogenetic tree represents a model of evolutionary history, where all organisms in the diagram are related to a common ancestral lineage (usually located at the bottom or far left of the graph). The branches of this rooted tree indicate evolutionary relationships, and each splitting point, known as a branch point, symbolizes the point at which an original lineage diversifies into a new and distinct one.

(ref:plottree) Phylogenetic tree of H3 influenza viruses. (A) A H3 influenza tree rectangular layout (B) A H3 influenza tree with a genotype table visualized as a heatmap

```{r plottree, fig.width=8, fig.height=12 , out.width='90%', dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:plottree)',fig.align='center'}

# install.packages("pacman")

library(pacman)

pacman::p_load(
  ggtree, # to visualize phylogenetic files
  ape,    # to import and export phylogenetic files
  treeio  # to visualize phylogenetic files
  )

beast_file <- system.file("examples/MCC_FluA_H3.tree", 
                    package="ggtree")
beast_tree <- read.beast(beast_file)
genotype_file <- system.file("examples/Genotype.txt", 
                    package="ggtree")
genotype <- read.table(genotype_file, sep="\t", 
                    stringsAsFactor=F)
colnames(genotype) <- sub("\\.$", "", colnames(genotype))

p1 <- ggtree(beast_tree, mrsd="2013-01-01") + 
    geom_tiplab(size=2, align=TRUE, 
                linesize=0.5) + 
    theme_tree2() +
    xlim(1990, 2020) +
    vexpand(0.03, -1)

p2 <-  ggtree(beast_tree, mrsd="2013-01-01") + 
      geom_tiplab(size=2,
               align=TRUE, 
               linesize=0.4) +
      theme_tree2()

g1 <- gheatmap(p2, genotype, offset=9.5, 
         width=0.6, 
         font.size=2, 
         hjust=0,
         colnames=FALSE, 
         legend_title="Genotype") +
      scale_x_ggtree() + 
      scale_y_continuous(expand=c(0, 0.3)) +
      vexpand(0.03, -1)

plot_list(p1, g1, ncol=1, tag_levels='A')

```

A subset of data containing 76 hemagglutinin H3 gene sequences from a lineage containing both swine and human influenza A viruses [@Liang2014] was used for these plots. This subset of data is included in the **ggtree** package. \index{ggtree} The ggtree package [@Yu3] is designed to annotate phylogenetic trees with their associated data of different types and from various sources. Before graphing the phylogenetic tree, files containing tree information must be analyzed, therefore, we must use the  **treeio** and **ape** packages.

```{r, error=FALSE, message=FALSE, warning=FALSE}

# install.packages("pacman")

library(pacman)

pacman::p_load(
  ggtree, # to visualize phylogenetic files
  ape,    # to import and export phylogenetic files
  treeio  # to visualize phylogenetic files
  )

beast_file <- system.file("examples/MCC_FluA_H3.tree", 
                         package="ggtree")
beast_tree <- treeio::read.beast(beast_file)

```

After loading the data, Figure \@ref(fig:plottree) (A) was generated using the `ggtree()` function and the argument `mrsd="2013-01-01”` to indicate the most recent sampling date. In addition, the `theme_tree2()` function allows a time scale to be displayed on the x-axis. The `geom_tiplab()` function adds the name of the sample at the end of its branch, with the option to connect it by dotted lines. Finally, the `xlim()` function was applied to limit the axis to show only the period between 1990 and 2020.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

p1 <- ggtree(beast_tree, mrsd="2013-01-01") + 
    geom_tiplab(size=2, align=TRUE, 
                linesize=0.5) + 
    theme_tree2() +
    xlim(1990, 2020) +
    vexpand(0.03, -1)
p1

```

The flexibility of the **ggtree** package allows you to add annotations or other schemes such as a heat map. For this we will use the `gheatmap()` function to visualize the phylogenetic tree with a heat map of an associated matrix (Figure \@ref(fig:plottree) (B)). \index{gheatmap, ggtree}

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

beast_file <- system.file("examples/MCC_FluA_H3.tree", 
                        package="ggtree")
beast_tree <- read.beast(beast_file)

genotype_file <- system.file("examples/Genotype.txt", 
                       package="ggtree")
genotype <- read.table(genotype_file, sep="\t", 
                       stringsAsFactor=F)
colnames(genotype) <- sub("\\.$", "", colnames(genotype))

p2 <-  ggtree(beast_tree, mrsd="2013-01-01") + 
      geom_tiplab(size=2,align=TRUE, 
               linesize=0.4) +
      theme_tree2()

gheatmap(p2, genotype, offset=9.5, 
         width=0.6, 
         font.size=2, 
         hjust=0,
         colnames=FALSE, 
         legend_title="Genotype") +
      scale_x_ggtree() + 
      scale_y_continuous(expand=c(0, 0.3)) +
      vexpand(0.03, -1)
```


```{block2, other2 , type='rmdtip'}

__Want to know more?__

- The `p_load()` function of the pacman package allows you to install the package if necessary and loads it for use. More details here https://github.com/trinker/pacman.

- If you want to know more about how to use the ggtree package, read the book online here https://yulab-smu.top/treedata-book/index.html. 

```


## UpSet plot {#upset-plot}

An important step in the investigation is to analyze the commonalities and differences between various sets through their intersections. Venn or Euler diagrams are a traditional way to visualize sets, but they are limited to showing the size of the intersections of only two or three sets. \index{UpSet plot} For this reason, UpSet is a more effective option for visualizing set data when working with more than three and less than 30 sets [@Lex2014].

(ref:upset) The UpSet plot showing the intersections of five mutated genes in tumors of patients with glioblastoma multiforme, sorted by size. Vertical bars indicate the number of genes in common (intersection size) for each specific combination of methods represented by the connected filled circles at the bottom. The horizontal bars show the total number of genes (set size) obtained from each integration method.

```{r upset, fig.width = 5.5*6/4.2, fig.asp = 0.7, dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:upset)',fig.align='center'}
library(pacman)
pacman::p_load(UpSetR)

mutations <- read.csv( system.file("extdata", 
          "mutations.csv", package = "UpSetR"), 
           header=T, sep = ",")
upset(mutations,
      sets = c("PTEN", "TP53", "EGFR", 
               "PIK3R1", "RB1"), 
      main.bar.color = "grey50",
      point.size = 3,
      text.scale = 1.5,
      sets.bar.color = c("grey50", "grey50", "grey50", 
                "grey50", "grey50"),
      queries = list(list(query = intersects, 
      params = list("EGFR"), color = "#1876ba",
      active = T)),
      order.by = "freq",
      mainbar.y.label = "Genes Intersections",
      sets.x.label = "Genes Mutated",
      empty.intersections = "on")

```

The UpSet chart represents the intersections of a set in matrix format, allowing you to effectively visualize associated data, such as the number of elements in each intersection. In the cells of this matrix, filled circles indicate the sets that are part of an intersection, and when connected by lines, they represent the elements shared between those sets. On the left, the horizontal bars show the total size of each set, while the vertical bars indicate the size of the intersections (Figure \@ref(fig:upset)).

The Figure \@ref(fig:upset) shows an example dataset of mutated genes in tumors from patients with glioblastoma multiforme. These data were obtained from the UpSet R [@Gehlenborg2] package and allowed us to perform Figure \@ref(fig:upset). The main function to make this chart is with `upset()`, then use arguments that control the color of the bars and the size of the labels in your chart. \index{upset, UpSetR} The gene bar with the most interaction was highlighted, using the `queries = list()` argument.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(pacman)

pacman::p_load(UpSetR)

mutations <- read.csv( system.file("extdata", 
          "mutations.csv", package = "UpSetR"), 
           header=T, sep = ",")
upset(mutations,
      sets = c("PTEN", "TP53", "EGFR", 
               "PIK3R1", "RB1"), 
      main.bar.color = "grey50",
      point.size = 3,
      text.scale = 1.5,
      sets.bar.color = c("grey50", "grey50", "grey50", 
                "grey50", "grey50"),
      queries = list(list(query = intersects, 
      params = list("EGFR"), color = "#1876ba",
      active = T)),
      order.by = "freq",
      mainbar.y.label = "Genes Intersections",
      sets.x.label = "Genes Mutated",
      empty.intersections = "on")
```


```{block2, other3 , type='rmdtip'}

__Want to know more?__

- An interactive tool for generating such visualizations in a web browser is available from https://vcg.github.io/upset/.

- A version of Shiny UpSetR app that you can upload your own data, enter here: https://gehlenborglab.shinyapps.io/upsetr/ 

- You can also make UpSet graphs with the ComplexHeatmap package [@Gu2].

```


## Heatmap {#heat-map}

Heatmaps are a common visualization in scientific publications and are used to display gene expression and other multivariate data. \index{Heatmap} These graphs represent two-dimensional tables of numbers using shades of color, so the choice of color scale is crucial [@Gehlenborg2012]. However, this representation may not be reliable for data with discrete values, so use with caution. Also, avoid the combination of red and green, as it makes access to information difficult for people with color blindness. 

French economist Toussaint Loua, in 1873, used colors to represent numbers within a table to track social statistics in different neighborhoods of Paris [@Loua]. It is one of the earliest examples of a heatmap!

(ref:heatmap2) Colored table made by the French economist Toussaint Loua in 1873.

```{r, echo = FALSE, fig.align='center', out.width='80%', fig.cap= '(ref:heatmap2)'}
knitr::include_graphics(rep("images/heatmap.png"))
```

Heat maps are ideal for presenting *next-generation sequencing* (NGS) data and provide an overview of the information. However, their major limitation is that the color shades make it difficult to accurately identify values due to the limitations of our visual perception. 

A heatmap (Figure \@ref(fig:heatmap3)) was generated employing an RNA-Seq dataset to characterize transcriptomic changes in four primary human airway smooth muscle (ASM) cell lines that were treated with dexamethasone [@Himes2014]. In this heatmap, a division into rows and columns is observed, where the rows correspond to gene names and the columns to sample names. A heat map can include annotations on all four sides of the graph (for example,dendrograms).

(ref:heatmap3) Heatmap showing the expression of 20 genes in four human airway smooth muscle cell lines treated with dexamethasone. Heat map grouped by a tree, to show hierarchical links between rows and columns. 

```{r heatmap3, fig.width = 5.5*6/4.2, fig.asp = 0.7, out.width='120%',dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:heatmap3)',fig.align='center'}

airway <-read.csv("data/Chapter07/RNAseq_mat_top20.csv",
              header=TRUE,row.names=1,
              check.names=FALSE)
library(pacman)
pacman::p_load(
  ComplexHeatmap,
  circlize,
  seriation
  )

at <-data.frame(sample=as.character(colnames(airway)),dex="Treatment")%>%
                column_to_rownames("sample")
at$dex <-ifelse(rownames(at) %in% c("508","512","516","520"),
                "untrt","trt")

colours <- list('dex' = c('untrt' = 'black', 'trt' = '#8d9690'))

col_att <- HeatmapAnnotation(
  df = at,
  which = 'col',
  col = colours,
  show_annotation_name = FALSE,
  show_legend = FALSE)

col_map = colorRamp2(seq(min(airway), max(airway), length = 4), 
           c("#018571", "#f5f5f5","#dfc27d", "#a6611a"))

hmap2 <- ComplexHeatmap::Heatmap(
          airway,
          name = "Expression",
          col = col_map,
          rect_gp = gpar(
          col = "white", 
          lwd = 2),
          width = unit(100, "mm"),
          top_annotation=col_att,
          column_km = 2,
          column_title = c("untrt", 
                        "trt"))

draw(hmap2, heatmap_legend_side="right",
     merge_legend = TRUE)


```

There are several functions for plotting heat maps in R, however, we will use one that is convenient and produces an attractive result, the ComplexHeatmap package [@Gu1]. Before plotting, we have to organize our data and the variable `at` was created to contain the information about the treatment group (*untrt*,*trt*). Then the color was chosen manually for the groups. Another important point is the colors for our matrix and the `colorRamp2` function from the circlize package was used as it allows you to easily generate color shades based on numerical data. Then the `HeatmapAnnotation` function was used to represent the treatment groups as a bar. An additional thing is to use the seriation technique to sort the matrix and for this you should use the **seriation** package.

```{r, error=FALSE, message=FALSE, warning=FALSE,eval=FALSE}

library(pacman)

pacman::p_load(
  ComplexHeatmap, # Plot the heatmap
  circlize,       # colorRamp2
  seriation       # sort the matrix
  )

airway <-read.csv("data/Chapter07/RNAseq_mat_top20.csv",
              header=TRUE,row.names=1,
              check.names=FALSE)
# Variable containing the treatment group
at <-data.frame(sample=as.character(colnames(airway)),
                dex="Treatment")%>%
                column_to_rownames("sample")

at$dex <-ifelse(rownames(at) %in% c("508","512","516","520"),
                "untrt","trt")
# Color according to treatment group
colours <- list('dex' = c('untrt' = 'black', 'trt' = '#fa82c2'))

# Coloring our matrix using colorRamp2
col_map = colorRamp2(seq(min(airway), max(airway), length = 4), 
          c("darkblue", "white","#eba432", "firebrick"))
# Display the treatment group by means of bars
col_att <- HeatmapAnnotation(
  df = at,
  which = 'col',
  col = colours,
  show_annotation_name = FALSE,
  show_legend = FALSE)

# Seriation to order our matrix 

o1 = seriate(dist(t(airway)), method = "TSP")
o2 = seriate(dist(airway), method = "TSP")

```

Finally, the `ComplexHeatmap::Heatmap` function was used to configure the body of the heatmap and supported with the `draw()` function to control the legend.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

hmap <- ComplexHeatmap::Heatmap(
          airway,
          name = "Expression",
          col = col_map,
          rect_gp = gpar(
          col = "white", 
          lwd = 2),
          # column_order = get_order(o1), # seriaton by TSP method
          # row_order = get_order(o2),
          width = unit(100, "mm"),
          top_annotation=col_att,
          column_km = 2,
          column_title = c("untrt", 
                        "trt"))

draw(hmap, heatmap_legend_side="right",
     merge_legend = TRUE)

```


```{block2, othermap , type='rmdtip'}

__Want to know more?__

- Another very useful package for plotting heat maps is with **pheatmap**.

- From version 2.5.2 of ComplexHeatmap, I implemented a new `ComplexHeatmap::pheatmap()` function which actually maps all the parameters in `pheatmap::pheatmap()`.

- cerebroViz [@Bahl2017] is a package developed to visualize anatomical regions of the brain with publication quality, displaying spatiotemporal data. This package focuses primarily on visualizing spatiotemporal gene expression.

```

## Chord diagram {#chord-plot}

The chord diagram is an intuitive visualization that represents interrelated data by curved arcs within a circle. \index{Chord diagram} This type of graph is commonly used to show relationships between various genes. @Finnegan19, used these diagrams to analyze contraceptive trajectories among women as recorded in the Demographic and Health Survey (DHS) contraceptive schedule.

(ref:chord) Chord diagram of the top 37 differentially expressed genes of brain and heart endothelial cells (3 replicates).

```{r chord, fig.width = 12, fig.height= 10.5,out.width='90%',dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:chord)',fig.align='center'}

library(pacman)

pacman::p_load(
        GOplot
        )

d <- circle_dat(EC$david, EC$genelist)

c <- chord_dat(data = d, genes = EC$genes, 
               process = EC$process)

GOChord(c, space = 0.02, gene.order = 'logFC', 
        gene.space = 0.25, gene.size = 4,
        lfc.col=c("#FF0000","#FFFFFF",
                  "#0000FF"),
        ribbon.col =c("#da6051", "skyblue",
          "#aa82fa","#edaf42","#059e73", 
          "#FB9A99", "#bfbfbf"))

```

A chord diagram was generated to visualize the major genes differentially expressed in brain and heart endothelial cells. This dataset is available in the **GOplot** package [@Wencke2], which was used to create our visualization. After installing the package, a variable containing the data of interest was created using the `circle_dat `function. Additionally, the data must be represented as a binary matrix and the `chord_dat` function was used for this purpose.

```{r, error=FALSE, message=FALSE, warning=FALSE}

library(pacman)

pacman::p_load(
        GOplot
        )

d <- circle_dat(EC$david, EC$genelist)

c <- chord_dat(data = d, genes = EC$genes, 
               process = EC$process)

head(c,4)

```

Then the `GOChord` function was used to make the string diagram. Within this function there are a variety of arguments to change the layout of the graph. \index{GOChord, GOplot}

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

GOChord(c, space = 0.02, gene.order = 'logFC', 
        gene.space = 0.25, gene.size = 4)

```

This type of visualization has one main drawback which is the visual clutter and bright colors presented by the chords. In a study it was proven that chord diagrams can display up to 100 data sets while maintaining aesthetics and readability [@Komarek2]. Finally, the colors you should choose should take into account the transparency and brightness. 

```{block2, otherchord , type='rmdtip'}

__Want to know more?__

The **circlize** package [@Zuguang15] is another very good option for plotting a string diagram. 

```


## Geospatial

There are data sets that can be represented in a geospatial context, either by realistic maps or map-like diagrams. Maps are often very intuitive and allow the addition of colors to geographic regions (such as districts), as well as the incorporation of lines, circles and other shapes. Among the different mapping techniques, the most common and certainly known from their presence in publications are choropleth maps. 

Choropleth maps use colors, shadows or patterns to highlight geographic areas, representing quantities or magnitudes in a proportional manner. Data typically visualized with this technique include mortality and birth rates, life expectancy, species diversity, among others. In Figure \@ref(fig:map1) we have a choropleth map. This map shows a dataset of COVID-19 incidence data from the first wave of transmission (2020) in Indian districts [@Pandey2022].

(ref:map1) Estimate of the month in which the first wave of COVID-19 began in the districts of India. Districts with no information available are shown in gray.

```{r map1, fig.asp = 0.75,dpi=300,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:map1)',fig.align='center'}

library(pacman)

pacman::p_load(
        tidyverse,
        sf
        )

files <- list.files(pattern="*.rds")

cov <- readRDS("data/Chapter07/COVID_wmet.rds")

d1 <- do.call(rbind.data.frame,strsplit(as.character(
     cov$Confirmed_StartDate_1),"-"))

colnames(d1) = c("Year","Month","Day")


cov$M1 = month.abb[as.numeric(as.character(d1$Month))]
cov$M1 = factor(cov$M1,levels=c("Apr","May","Jun",
                  "Jul","Aug","No Data"))
cov$M1[is.na(cov$S1)] = "No Data"

ggplot() + geom_sf(data = cov, aes(fill = M1),
            color=NA) + 
  coord_sf(datum = NA, expand = FALSE) +
  scale_fill_manual(values = c(
            viridis::inferno(5)[1:4],
            "#1876ba","gray50"),
            name="First-wave\n(Starting month)") + 
  labs(title="Year: 2020")+ 
  guides(fill = guide_legend(ncol = 3)) +
  theme_us_classic() +
  theme(plot.title = element_text(size=18),
      axis.title = element_blank(),
      axis.line = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      legend.position = c(1.1, 0.81),
      legend.justification = c(1, 0),
       plot.margin = margin(2, 2, 2, 1.5))


```

To load our file, the base function `readRDS()` was used. A new variable was generated to record the months of confirmed cases; however, in some districts there is no data available, so the value *“No Data”* was assigned. The map was created using the `geom_sf()` function of the ggplot2 package. The code is presented below.


```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(pacman)

pacman::p_load(
        tidyverse,
        sf
        )

files <- list.files(pattern="*.rds")

cov <- readRDS("data/Chapter07/COVID_wmet.rds")

d1 <- do.call(rbind.data.frame,strsplit(as.character(
     cov$Confirmed_StartDate_1),"-"))

colnames(d1) = c("Year","Month","Day")


cov$M1 = month.abb[as.numeric(as.character(d1$Month))]
cov$M1 = factor(cov$M1,levels=c("Apr","May","Jun",
                  "Jul","Aug","No Data"))
cov$M1[is.na(cov$S1)] = "No Data"

ggplot() + geom_sf(data = cov, aes(fill = M1),
            color=NA) + 
  scale_fill_manual(values = c(
            viridis::inferno(5)[1:4],
            "#1876ba","gray50"),
            name="First-wave\n(Starting month)") + 
  labs(title="Year: 2020")+ 
  theme_us_classic() +
  theme(plot.title = element_text(size=18),
      axis.title = element_blank(),
      axis.line = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      legend.position = c(1.18, 0.7))

```

Although choropleth maps provide an excellent visual impression, they can distort the information and can be misleading. Limitations include: the possibility of creating artificial demarcations or suggesting non-existent boundaries, as well as the difficulty in interpreting different shades of color, which can complicate reading. In addition, they become difficult to interpret if they represent values with more than two attributes.

Another type of map commonly used to represent epidemiological data is the *dot map*. In this format, each case is displayed as a dot on the map, reflecting the absolute number of cases. This approach allows visualizing the size of the outbreak and highlighting areas where no cases have been reported [@Soetens2017].

A data set from a study reporting the high pathogenicity of the H5N1 virus of clade 2.3.4.4b, related to a massive outbreak in southern elephant seals (*Mirounga leonina*) in Argentina, will be analyzed below. The study also raises the possibility of transmission among mammals [@Uhart2024].


(ref:map2) Hypothetical pathways for the spread of HPAI H5N1 viruses (2.3.4.4b) in South America, 2022-2023. H5Nx HPAI detections (1-Sep-2022 to 31-Dec-2023) reported to the World Animal Health Information System (WAHIS/WOAH) and by the Chilean Servicio Agrícola y Ganadero (SAG) are represented by orange circles (wild birds), green triangles (domestic birds) and blue squares (mammals). 

```{r map2,fig.asp = 0.75,dpi=300,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:map2)',fig.align='center'}

library(pacman)

pacman::p_load(
        readxl,
        rnaturalearth,
        rnaturalearthdata
        )

influenza <- read_xlsx(path = 
        "data/Chapter07/influenza.xlsx",
        sheet = "Figure 4",
        col_names = TRUE,
        .name_repair = "unique_quiet") %>%
    rename(
          OutbreakId = `...2`,
          Group = `...3`,
          Category = `...4`,
          Latitude = `...5`,
          Longitude = `...6`,
          Source = `...7`) %>%
    select(
      everything(), -Source, - "Figure 4"
    ) %>%
   slice(-c(1, 2))
          
influenza$Latitude = as.numeric(influenza$Latitude)
influenza$Longitude = as.numeric(influenza$Longitude)

delete_row <- c("Domestic and wild")

influenza2 = influenza %>% 
       filter(!(Category == delete_row)) %>% 
       mutate(
         group_cat = paste(Group, Category, 
        sep = '_'))

world <- ne_countries(scale = "large", 
            returnclass = "sf")

ggplot(data =world ) + 
  geom_sf() + 
    coord_sf(xlim = c(-92, -25), 
             ylim = c(20, -59), 
           expand = FALSE) +
   geom_point(
     data = influenza2,
      aes(x = Longitude,
      y = Latitude,
      fill = group_cat,
      shape = group_cat),
      size = 1.5, color = "black"
   ) + 
   scale_fill_manual(
     name= "H5N1 HPAI\ndetections:",
     breaks=c("Bird_Domestic", 
              "Bird_Wild",
              "Mammal_Wild"),
     values=c("#70eb33", "#f3a605",
              "#1876ba"),
     labels=c("Birds (domestic)",
              "Birds (wild)",
              "Mammals")) +
  scale_shape_manual(
    name = "H5N1 HPAI\ndetections:",
    breaks=c("Bird_Domestic", 
              "Bird_Wild",
              "Mammal_Wild"),
    labels=c("Birds (domestic)",
              "Birds (wild)",
              "Mammals"),
    values = c(24,21,22)) + 
   theme_us_classic() + 
   theme(
      axis.title = element_blank(),
      axis.line = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      legend.key = element_blank(),
      legend.position = c(1.1, 0.8),
       plot.margin = margin(2, 2, 2, 1.5))

```

After entering and polishing our data, the **rnaturalearth** package [@South20] was used to obtain a map of countries around the world. The `ne_countries` function was used to extract country data and choose the scale (`scale = “large”`). The function can return `sp` classes (default) or directly `sf` classes, as defined in the argument `returnclass`.

To plot the dot map (Figure \@ref(fig:map2)) ggplot2 was used and in the `geom_point()` function the coordinates of the points were added with the argument `aes(x = Longitude, y = Latitude)`. Like any point plot, the characteristics of interest (e.g., border color, fill and shape) were adjusted. Finally, `coord_sf()` was used to establish limits. 

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(pacman)

pacman::p_load(
        readxl,
        rnaturalearth,
        rnaturalearthdata
        )
# Data entry and cleaning
influenza <- read_xlsx(path = 
        "data/Chapter07/influenza.xlsx",
        sheet = "Figure 4",
        col_names = TRUE,
        .name_repair = "unique_quiet") %>%
    rename(
          OutbreakId = `...2`,
          Group = `...3`,
          Category = `...4`,
          Latitude = `...5`,
          Longitude = `...6`,
          Source = `...7`) %>%
    select(
      everything(), -Source, - "Figure 4"
    ) %>%
   slice(-c(1, 2))

# Change the variable type
influenza$Latitude = as.numeric(influenza$Latitude)
influenza$Longitude = as.numeric(influenza$Longitude)

# New variable having the union of two variables
delete_row <- c("Domestic and wild")

influenza2 = influenza %>% 
       filter(!(Category == delete_row)) %>% 
       mutate(
         group_cat = paste(Group, Category, 
        sep = '_'))

world <- ne_countries(scale = "large", 
            returnclass = "sf")

# Plot our map
ggplot(data =world ) + 
  geom_sf() + 
    coord_sf(xlim = c(-92, -25), 
             ylim = c(20, -59), 
           expand = FALSE) +
   geom_point(
     data = influenza2,
      aes(x = Longitude,
      y = Latitude,
      fill = group_cat,
      shape = group_cat),
      size = 1.5, color = "black"
   ) + 
   scale_fill_manual(
     name= "H5N1 HPAI\ndetections:",
     breaks=c("Bird_Domestic", 
              "Bird_Wild",
              "Mammal_Wild"),
     values=c("#70eb33", "#f3a605",
              "#1876ba"),
     labels=c("Birds (domestic)",
              "Birds (wild)",
              "Mammals")) +
  scale_shape_manual(
    name = "H5N1 HPAI\ndetections:",
    breaks=c("Bird_Domestic", 
              "Bird_Wild",
              "Mammal_Wild"),
    labels=c("Birds (domestic)",
              "Birds (wild)",
              "Mammals"),
    values = c(24,21,22)) + 
   theme_us_classic() + 
   theme(
      axis.title = element_blank(),
      axis.line = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      legend.key = element_blank(),
      legend.position = c(1.1, 0.8))

```

The main limitation of **dot maps** is that they do not consider the geographic distribution of the population. In addition, they can provide an excess of information on the exact location of individual cases, which makes interpretation of the data difficult.

An alternative way to represent population distribution and correct the geographic distortion of a choropleth map is the use of a *cartogram*. Cartograms adjust the size of geographic units according to population density, which allows the impact of diseases such as cancer to be more accurately reflected. 

Figure \@ref(fig:cartogram) presents a contiguous cartogram of the U.S. population in 2015. The state of California appears significantly larger due to its high population density, which is confirmed by the data (> 30 million inhabitants). 

(ref:cartogram) Contiguous cartogram of the U.S. population in 2015. A cartogram sizes the area of geo-spatial objects proportional to some metric (e.g., population). All states are visible and the general shape of the United States is still recognizable. Data: 2015 Five-Year American Community Survey. 

```{r cartogram,fig.asp = 0.73,dpi=300,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:cartogram)',fig.align='center'}

library(pacman)

pacman::p_load(
        tigris,
        tidyverse,
        colorspace
        )


load("data/Chapter07/US_income_cartogram.rda")


US_cartogram <-  US_income_cartogram %>%
                 dplyr::mutate(
                  pop = cut(
                 ifelse(is.na(population), 
                   25000, population),
                   breaks = c(0, 
                             10000000, 
                             20000000, 
                             30000000,
                             40000000),
                  labels = c("< 10M", 
                             "10M to 20M", 
                             "20M to 30M",
                             "> 30M"),
                  right = FALSE
                  ))

US_income_cartogram$pop <- US_cartogram$pop

ggplot(data = US_income_cartogram,
          aes(fill = pop)) + 
  geom_sf(color = "gray20",size = 0.2) +
  coord_sf(datum = NA, expand = FALSE) +
  scale_x_continuous(limits = c(-3900000, 
                    2500000)) +
  scale_fill_discrete_sequential(
    palette = "Burg", nmax = 4,
    p2 = 1.2,
    name = "Population",
    guide = guide_legend(
      override.aes = list(colour = 
          "white", size = 1),
      reverse = TRUE
    )) + 
  theme_us_classic() + 
  theme(
    legend.position = c(0, 1),
    legend.justification = c(0, 1),
    plot.margin = margin(2, 2, 2, 1.5)
  )

```

A dataset called “US_income_cartogram.rda” published in support materials by [Claus Wilke](https://github.com/clauswilke/dviz.supp) was used to make this map. After entering the data, a new variable classifying the population into different categories (e.g. < 10M) was generated using the `mutate()` function of the *dplyr* package. Subsequently, this new variable was integrated into the main dataset.

The visualization of the cartogram was done using `geom_sf()` and `coord_sf()` from the *ggplot2* package. \index{geom\_sf function} The coord_sf() function allows specifying a transformation of the coordinate reference system to be used for the visualization. Finally, some adjustments were made, such as color, for which the **colorspace** package [@Uhart2024] was used since it contains a series of intuitive color palettes.  \index{coord\_sf function} 

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(pacman)

pacman::p_load(
        tidyverse,
        colorspace # color palettes
        )


load("data/Chapter07/US_income_cartogram.rda")

# A new variable called “pop”
US_cartogram <-  US_income_cartogram %>%
                 dplyr::mutate(
                  pop = cut(
                 ifelse(is.na(population), 
                   25000, population),
                   breaks = c(0, 
                             10000000, 
                             20000000, 
                             30000000,
                             40000000),
                  labels = c("< 10M", 
                             "10M to 20M", 
                             "20M to 30M",
                             "> 30M"),
                  right = FALSE
                  ))
# Introduction of the variable to our original data
US_income_cartogram$pop <- US_cartogram$pop
# Plotting our contiguous cartogram
ggplot(data = US_income_cartogram,
          aes(fill = pop)) + 
  geom_sf(color = "gray20",size = 0.2) +
  coord_sf(datum = NA, expand = FALSE) +
  scale_x_continuous(limits = c(-3900000, 
                    2500000)) +
  scale_fill_discrete_sequential(
    palette = "Burg", nmax = 4,
    p2 = 1.2,
    name = "Population",
    guide = guide_legend(
      override.aes = list(colour = 
          "white", size = 1),
      reverse = TRUE
    )) + 
  theme_us_classic() + 
  theme(
    legend.position = c(0, 1),
    legend.justification = c(0, 1),
    plot.margin = margin(2, 2, 2, 1.5)
  )

```

It is important to be cautious when using contiguous cartograms when there is a large dissonance between the population density of geographic units and their spatial density.

```{block2, car1 , type='rmdtip'}

__Want to know more?__

- The `sf` package [@Pebesma20] can be used to represent and work with spatial vector data including points, polygons, and lines, and their associated information.
- The `tigris` package [@Walker20] facilitates access to census geographic datasets obtained directly from the U.S. Census Bureau website. In addition, it includes a feature that allows the geometries of Alaska, Hawaii and Puerto Rico to be projected into coordinate reference systems appropriate for these regions. It then resizes the geometries and repositions them in an alternative layout relative to the rest of the U.S. territory, using the Albers equivalent area coordinate system.
- The `mapview` package [@Appelhans20] allows us to create interactive maps very quickly.
- The R package cartogram [@Jeworutzki05] provides an interface to several popular cartogram algorithms.

```


## Tables {#table}

Tables are a useful tool for visualizing data. In publications, you almost always include at least one table, especially when you need to show the exact amount of each value in the data. Therefore, it is important to learn how to design an effective table that makes it easy for the reader to understand your findings.

If you prefer to make a table in Microsoft Word or Microsoft Excel, that's fine, and both offer predefined table styles. However, you should be careful, as many of these styles are not optimally formatted. This time, we will use R packages to create simple and easy-to-manage tables.

Before designing a table, we will share some tips to improve them:

1. Do not use grid lines or alternating gray separators for each entry, as this is unnecessary. 
2. Shading can be used to highlight a column of data or a specific entry (e.g., outliers).
3. Use horizontal lines as a frame for the entire table and separator between the title row and the first data row. 
4. Align the numbers to the right and your header should also be aligned to the right with the numbers. 
5. Align the text to the left and its heading should also be left-aligned. 
6. A table with a lot of comparative data should be presented vertically as it allows the reader to grasp the information more easily and is more compact.

```{r tabl1, echo=FALSE, error=FALSE, fig.align='center', fig.height=9, fig.width=6, message=FALSE, warning=FALSE, dpi=300, out.width='80%'}

library(knitr)
library(kableExtra)
library(tidyverse)
d1 <- read.csv(
        file = "data/Chapter07/Chinook.csv", 
        header = TRUE,  sep=",") 

d2 <- d1 %>%
  dplyr::select(troutTreatment,
          nReleased,
          nSurvivors,
          proportionSurvived) %>%
  dplyr::rename( 
      `Brook trout` = troutTreatment,
      `Number of salmon surviving` = nSurvivors,
       `Number of salmon released` = nReleased, 
       `Proportion of surviving` = proportionSurvived)

knitr::kable(d2, 
    caption = 
  "The numbers and proportion of chinook 
  released and surviving in streams with and without 
  brook trout.[note]",   
  row.names = FALSE,
  format = "latex",
  booktabs = TRUE) %>%
  kable_styling(font_size = 15,
      latex_options="scale_down") %>%
  add_footnote(c("The study included 12 streams in total"),
               notation = "symbol")


```

Table \@ref(tab:tabl1) was constructed using the knitr and kableExtra [@Zhu20] packages. A data set related to survival analysis of a native species, Chinook salmon (*Oncorhynchus tshawytscha*), was entered for a series of 12 streams where brook trout (*Salvelinus fontinalis*) were introduced or not introduced [@Levin2002]. 

After entering the data, we selected the variables to be used and renamed the variable labels using the `rename` function of *dplyr*. Subsequently, we built the table with knitr 's `kable` function and enhanced it with the *kableExtra* package. A common feature in tables is to add footnotes, which provide additional information on how the data were obtained and, if necessary, define the abbreviations used in the table. Footnotes are added using the `add_footnote` function.

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}
library(knitr)
library(kableExtra)

d1 <- read.csv(
        file = "data/Chapter07/Chinook.csv", 
        header = TRUE,  sep=",") 

d2 <- d1 %>%
  dplyr::select(troutTreatment,
          nReleased,
          nSurvivors,
          proportionSurvived) %>%
  dplyr::rename( 
      `Brook trout` = troutTreatment,
      `Number of salmon surviving` = nSurvivors,
       `Number of salmon released` = nReleased, 
       `Proportion of surviving` = proportionSurvived)

knitr::kable(d2, 
    caption = 
  "The numbers and proportion of chinook 
  released and surviving in streams with and without 
  brook trout.[note]",   
  row.names = FALSE,
  format = "latex",
  booktabs = TRUE) %>%
  kable_styling(font_size = 15,
      latex_options="scale_down") %>%
  add_footnote(c("The study included 12 streams in total"),
               notation = "symbol")

```

The results of an experiment can be presented in tables or graphs, although it is rare to show the same data in both formats. So how do you decide which to use? A useful rule of thumb is to opt for a graph if the data show a clear trend that is best appreciated visually. On the other hand, if the data do not show an obvious trend, a table is preferable, as it saves space and allows you to see the exact values.

(ref:fig2) Proportion of chinook salmon surviving in streams with and without brook trout. Means and 95% confidence intervals are indicated with error bars to the right of the data. 

```{r fig2, out.width = "0.9\\linewidth", fig.width = 6, fig.asp = 0.6,dpi=300,dpi=300,echo=FALSE,error=FALSE, warning=FALSE, message=FALSE, fig.cap= '(ref:fig2)',fig.align='center'}

library(tidyverse)

d1 <- read.csv(
        file = "data/Chapter07/Chinook.csv", 
        header = TRUE,  sep=",") 

ggplot(d1, aes(x = troutTreatment, 
               y = proportionSurvived)) +
    geom_point(color = "gray50", size = 3,
               alpha = 0.5) +
    stat_summary(fun.data = mean_cl_normal, geom = "errorbar", 
        width = 0.05, position=position_nudge(x = 0.15),
        color = "gray40") +
    stat_summary(fun.y = mean, geom = "point", color = "#42598a",
        size = 3, position=position_nudge(x = 0.15)) +
    labs(x = "Treatment", y = "Proportion surviving") + 
    scale_x_discrete(limits =c("present",
                               "absent"),
              labels = c("present" = "Trout present", 
               "absent" = "Trout absent")) +
    scale_y_continuous(limits = c(0,0.4)) + 
    theme_us_classic() + 
    theme(axis.title.x = element_blank())

```

With this in mind, let us review our Table \@ref(tab:tabl1) in more detail. Although the format is adequate, the information is redundant and makes understanding the data at a glance difficult, requiring more time to comprehend. In addition, the most relevant part of the table is the survival ratio. Figure \@ref(fig:fig2) shows exactly the same data, but clearly outperforms the table, as it allows us to see immediately that Chinook survival is higher in the absence of brook trout.

```{r tabl2, echo=FALSE, error=FALSE, fig.align='center', fig.height=9, fig.width=6, message=FALSE, warning=FALSE, dpi=300, out.width='80%'}

library(kableExtra)

library(modelsummary)

w1 <- read.csv2(
        file = "data/Chapter07/winequality_white.csv", 
        header = TRUE)

w2 <- read.csv2(
        file = "data/Chapter07/winequality_red.csv", 
        header = TRUE)

w1['type'] <- 'White wine'
w2['type'] <- 'Red wine'

wines1 <- rbind(w1, w2)

wines2 <- wines1 %>% 
         dplyr::select(
           fixed.acidity, volatile.acidity,
           citric.acid, residual.sugar,chlorides,
           free.sulfur.dioxide,total.sulfur.dioxide,
           density,pH,sulphates,alcohol,type) %>%
         dplyr::rename( 
            `Fixed acidity` = fixed.acidity,
             `Volatile acidity` = volatile.acidity,
             `Citric acid` = citric.acid, 
              `Residual sugar` = residual.sugar, 
               `Chlorides` = chlorides, 
                `Free sulfur dioxide`= free.sulfur.dioxide,
                `Total sulfur dioxide` = total.sulfur.dioxide,
               `Density` = density, 
                 `Sulphates`= sulphates, 
                  `Alcohol`= alcohol)

wines2$`Fixed acidity` = as.numeric(wines2$`Fixed acidity`)
wines2$`Volatile acidity` = as.numeric(
                          wines2$`Volatile acidity`)
wines2$`Citric acid` = as.numeric(wines2$`Citric acid`)
wines2$`Residual sugar` = as.numeric(
                          wines2$`Residual sugar`)
wines2$`Chlorides` = as.numeric(wines2$`Chlorides`)
wines2$`Free sulfur dioxide` = as.numeric(
                          wines2$`Free sulfur dioxide`)
wines2$`Total sulfur dioxide` = as.numeric(
                          wines2$`Total sulfur dioxide`)
wines2$`Density` = as.numeric(wines2$`Density`)
wines2$`Sulphates` = as.numeric(wines2$`Sulphates`)
wines2$`Alcohol` = as.numeric(wines2$`Alcohol`)
wines2$pH = as.numeric(wines2$pH)

datasummary( `Alcohol` +
        `Citric acid` +
        `Chlorides` + 
        `Density` + 
        `Fixed acidity` +
        `Free sulfur dioxide` +
          pH + 
        `Residual sugar` +
        `Sulphates` + 
          `Total sulfur dioxide` +
          `Volatile acidity`
            ~ type * (Min + Max + Mean), 
             data = wines2, 
          title = "The physicochemical data statistics
                    per wine type.",
          output = 'kableExtra') %>%
         kableExtra::add_footnote(
           c("Data available in the UCI Machine 
                  Learning Repository")
         )


```

Summary tables, which present statistical results of the data, are also common in publications. Including statistical results increases the informative value of the tables. There are many packages for creating such tables, but modelsummary [@JSS22] was used here because of its flexibility and compatibility with other packages, such as **kableExtra**. 

A dataset on the quality of red wine from northern Portugal, available in the UCI Machine Learning Repository, was used. These data come from the research of @cortez2009 , which aimed to model wine quality (red and white) based on physicochemical tests (Table \@ref(tab:tabl2)).

The data were entered and a variable called `type` was created in both data (red wine and white wine) and then merged to have a single data set that includes both types of wine. The variables were then selected and renamed using dplyr's `rename` function. However, manually we have to change some variables to numerical values. 

```{r, error=FALSE, message=FALSE, warning=FALSE}

w1 <- read.csv2(
        file = "data/Chapter07/winequality_white.csv", 
        header = TRUE)

w2 <- read.csv2(
        file = "data/Chapter07/winequality_red.csv", 
        header = TRUE)

w1['type'] <- 'White wine' # create the “type” variable
w2['type'] <- 'Red wine'

wines1 <- rbind(w1, w2) # merge both data

wines2 <- wines1 %>% 
   dplyr::select(
           fixed.acidity, volatile.acidity,
           citric.acid, residual.sugar,chlorides,
           free.sulfur.dioxide,total.sulfur.dioxide,
           density,pH,sulphates,alcohol,type) %>%
    dplyr::rename( 
        `Fixed acidity` = fixed.acidity,
        `Volatile acidity` = volatile.acidity,
          `Citric acid` = citric.acid, 
          `Residual sugar` = residual.sugar, 
          `Chlorides` = chlorides, 
          `Free sulfur dioxide`= free.sulfur.dioxide,
          `Total sulfur dioxide` = total.sulfur.dioxide,
          `Density` = density, 
          `Sulphates`= sulphates, 
            `Alcohol`= alcohol)

wines2$`Fixed acidity` = as.numeric(wines2$`Fixed acidity`)
wines2$`Volatile acidity` = as.numeric(
                          wines2$`Volatile acidity`)
wines2$`Citric acid` = as.numeric(wines2$`Citric acid`)
wines2$`Residual sugar` = as.numeric(
                          wines2$`Residual sugar`)
wines2$`Chlorides` = as.numeric(wines2$`Chlorides`)
wines2$`Free sulfur dioxide` = as.numeric(
                          wines2$`Free sulfur dioxide`)
wines2$`Total sulfur dioxide` = as.numeric(
                          wines2$`Total sulfur dioxide`)
wines2$`Density` = as.numeric(wines2$`Density`)
wines2$`Sulphates` = as.numeric(wines2$`Sulphates`)
wines2$`Alcohol` = as.numeric(wines2$`Alcohol`)
wines2$pH = as.numeric(wines2$pH)

```

With the data set prepared, the Table \@ref(tab:tabl2)  was constructed using the `datasummary()` function, configuring it to display the minimum, maximum and mean value of the variables. When looking at the table, you will notice that the numeric values are displayed to two decimal places, including rounded integers, which allows the decimals to be aligned evenly. A word of advice: it is important to consider the level of precision you wish to display; you must find a balance between adequate precision and clarity of the table for ease of understanding. Finally, we link our table with some **kableExtra** functions, to improve our table. 

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}
# install.packages('modelsummary') 
library(kableExtra)
library(modelsummary)

datasummary( `Alcohol` +
        `Citric acid` +
        `Chlorides` + 
        `Density` + 
        `Fixed acidity` +
        `Free sulfur dioxide` +
          pH + 
        `Residual sugar` +
        `Sulphates` + 
          `Total sulfur dioxide` +
          `Volatile acidity`
            ~ type * (Min + Max + Mean), 
             data = wines2, 
          title = "The physicochemical data statistics
                    per wine type.",
          output = 'kableExtra') %>%
kableExtra::add_footnote(
    c("Data available in the UCI Machine 
              Learning Repository")
         )

```

The elaboration of this table would be acceptable for a publication and would be complemented with other graphs according to the purpose of the study. 


```{block2, ta1 , type='rmdtip'}

__Want to know more?__

- The gtsummary [@gtsummary] package and the `tbl_summary()` function also allows you to add summary statistics to your tables.

- The `rbind` function allows you to combine objects by rows or columns.

```

## In conclusion 


We have explored several variants of plots using extensions to ggplot2. These representations are adaptations or combinations of basic plots, such as bar, density and line plots. In addition, certain data sets can be visualized using realistic maps or diagrams with a map-like structure.

However, graphs are not the only way to present information; tables are also an effective option. To design a clear and understandable table, it is important to follow certain guidelines that facilitate the transmission of data to readers more effectively.

## To practice!

### Exercise 1

You will use an expression dataset of 131 glioblastoma multiforme proteins (download it here: https://tcga-xena-hub.s3.us-east-1.amazonaws.com/download/TCGA.GBM.
sampleMap%2FRPPA_RBN.gz). Some of the code is shown below:

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(pacman)

pacman::p_load(
        tidyverse,
        ComplexHeatmap
        )
rppa0 <- read.table(
        file = "_book/datos/RPPA_RBN",
        sep="\t",
        head=TRUE,
        row.names=1)
# Analyzes 131 proteins and 20 samples
rppa1 = rppa0[1:131, 1:20]
rppa1 <- as.matrix(rppa1)

```

### Exercise 2 

Uses a dataset on the average age-adjusted incidence rate of lung and bronchus disease in women and men in the United States between 2012 and 2016 [@ACE6040].

After entering and clearing the data, it plots a continuous cartogram. Some of the code is shown below:

```{r, warning=FALSE, message=FALSE, error=FALSE,eval=FALSE}

library(pacman)

pacman::p_load(
        tidyverse,
        sf
        )

cancer01 <- read.csv(
         file = "data/Chapter07/USCSlung.csv",
         header = TRUE
         )

cancer02 <-  cancer01 %>% 
  rename(name = Area) %>%
  mutate(
  `Age adjusted rate\n(per 100,000)` = AgeAdjustedRate)

load("data/Chapter07/US_income_cartogram.rda")

cancer02 <- left_join(US_income_cartogram, 
            cancer02, by = c("name"))
cancer02 <- st_transform(cancer02, 3857)

```
